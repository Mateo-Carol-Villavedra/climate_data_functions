---
title: "Downloading Climate Rasters"
author: "Mateo Carol Villavedra"
date: "2025-09-26"
output: html_document
---


NOTE - The scripts as part of this GITHUB Repository are designed to download and process DAILY climate data. Modification will need to made by the user to use these scripts for monthly average climate data. 




# download_AWAP_clim.data


This function downloads and processses annual raster grids from the AGCD (previously known as BOM AWAP) climate dataset for user specified years.

The function also reprojects all rasters to CRS 4326 and crops rasters to reduce downstream computational load, using a user supplied shapefile to encompass the region where data is needed.

Files are automatically saved to directories based on which variable they document, their state (direct download or cropped/reprojected).

```{r function for downloading Climate Data from BOM AWAP}

# Function INPUT DATA     ----


#    -    first_year                -  the first year from which to download the data


#...............................................................................................................................................................................


#    -    last_year                 -  the last year from which to download the data


#...............................................................................................................................................................................


#    -    year_interval             -  the interval between years (i.e. 1 = every year, 2 = every second year, 10 = once a decade, etc.)


#...............................................................................................................................................................................


#    -    awap_clim.var             -  a string of variable names which match those used by BOM AWAP database
                                             # VARIABLES AVAILABLE FROM THE BOM AWAP DATABASE:
                                             #..............................................................................
                                             # Precipitation                    =  "precip"                 From 1900
                                             # Maximum Temperature              =  "tmax"                   From 1910
                                             # Minimum Temperature              =  "tmin"                   From 1910
                                             # Vapour Pressure (9am / 09:00)    =  "vapourpres_h09"         From 1971
                                             # Vapour Pressure (3pm / 15:00)    =  "vapourpres_h15"         From 1971


#...............................................................................................................................................................................


#    -    directory                 -  the file directory to save the downloaded data (formatted as "../folder1/subfolder")
#                                         -  direct downloads will be saved to a subdirectory called "raw"
#                                         -  cropped and reprojected files will be saved to a subdirectory called "processed"


#...............................................................................................................................................................................


#    -    overwrite_download        -  whether or not to to overwrite existing direct downloaded year raster files with new downloads
#                                         -  default = FALSE
#                                         -  If FALSE and the file already exists, 
#                                                           the function will either crop (if the file exists and the "overwrite_crop" option is TRUE)
#                                                            or move onto the next year for that variable. 


#...............................................................................................................................................................................


#    -    crop_shape                -   a Shapefile of a polygon which entirely encompasses the desired region for sampling
#                                                                       used to crop the rasters after downloading to reduce file size. 
#                                         -  User Must ensure that the polygon is valid and in CRS: 4326
#                                         -  In order to preserve all required datapoint, the polygon should have a margin of a few cells from the first cell actually needed
#                                                     as slight mismatches between climate databases with regard to raster extent can cause issues downstream. 


#...............................................................................................................................................................................


#    -    overwrite_download        -  whether or not to to overwrite existing direct downloaded year raster files with new downloads
#                                         -  Default = FALSE
#                                         -  If FALSE and the file already exists, 
#                                                            the function will either crop (if the file exists and the "overwrite_crop" option is TRUE)
#                                                             or move onto the next year for that variable. 
#                                         -  If TRUE, then all downloads will be overwritten with new downloads. 


#...............................................................................................................................................................................


#    -    overwrite_crop            -  whether or not to overwrite existing cropped raster files which new cropped raster files from existing uncropped downloads. 
#                                         -  default = FALSE
#                                         -  If FALSE and the cropped files already exist, then the function will move onto the next
#                                         -  If FALSE but the cropped files don't exist, new cropped files will be produced. 
#                                         -  If TRUE, then all files will be cropped and saved. 

#----


download_AWAP_clim.data <- function(first_year, last_year, year_interval, awap_clim.var, directory, crop_shape, overwrite_download = FALSE, overwrite_crop = FALSE) {
     
     # Ensuring Packages are Loaded:
     library(curl)
      library(terra)
     
     # Defining the year to iterate the function over to download the required climate data:
     data_years <- seq(from = first_year, to = last_year, by = year_interval)
     
     
     # Check for Function    ----
     
     # Ensuring User Defined first year is not earlier than the first year from which climate data is available from BOM AWAP
     if(first_year < 1900) {
          stop("First Year of Climate Data Available from BOM AWAP = 1900")
                             cat("\n")
     }
     
     # Ensuring that the year interval is not less than 1
     if(year_interval < 1) {
          stop("Minimum Year Interval is 1")
                             cat("\n")
     }

     
     # Ensuring that the first year is not later than the last year:
     if(first_year > last_year) {
          stop("First Year must be at least 1 year prior to last year")
                             cat("\n")
     }
     
     
      # If crop_shape is a filepath, read it in
      if (is.character(crop_shape)) {
        if (!file.exists(crop_shape)) {
          stop("The crop_shape file path does not exist: ", crop_shape)
                             cat("\n")
        }
        crop_shape <- terra::vect(crop_shape)
      } else if (!inherits(crop_shape, c("SpatVector", "SpatRaster"))) {
        stop("crop_shape must be a terra SpatVector, SpatRaster, or a valid file path")
                             cat("\n")
      }
     #----
     
     
     
     # VARIABLES AVAILABLE FROM THE BOM AWAP DATABASE:
     # Precipitation                    =  "precip"              From 1900
     # Maximum Temperature              =  "tmax"                From 1910
     # Minimum Temperature              =  "tmin"                From 1910
     # Vapour Pressure (9am / 09:00)    =  "vapourpres_h09"        From 1971
     # Vapour Pressure (3pm / 15:00)    =  "vapourpres_h15"        From 1971
     
     # Checking that the user defined variables match those used by the BOM AWAP database  ----
     # List of acceptable variable names:
     true_var.names <- c("precip", "tmax", "tmin", "vapourpres_h09", "vapourpres_h15")
     
     # Checking that all variables defined by the user are within the list of "true variable names"
     invalid_var.names <- awap_clim.var[!awap_clim.var %in% true_var.names]
     
     if(length(invalid_var.names) > 0) {
          # if the user defined variables are not present then the function will stop and force an error:
          stop(paste0("User Selected Variable Names Not Matching to BOM AWAP Names. 
               
               Invalid Variable Names:", paste(invalid_var.names, collapse = ", ")))
                             cat("\n")
     }
     #----
     
     
     # Defining the database Central directory:
     AWAP_directory <- "https://thredds.nci.org.au/thredds/fileServer/zv2/agcd/v1-0-2/"
     
     
     # Looping through each variable
     for (var in awap_clim.var) {  
          
          
            # Creating output folders
            var.output_dir <- paste0(directory, "/", var, "/raw")
            dir.create(var.output_dir, recursive = TRUE, showWarnings = FALSE)
            
            # Output folder for processed (cropped + reprojected) files
            var.processed_dir <- paste0(directory, "/", var, "/processed")
            dir.create(var.processed_dir, recursive = TRUE, showWarnings = FALSE)
         
          
          
          # Defining the repository depending on the climate data:
          # Also defining valid year for each variable      ----
          if(var == "precip") {
               awap.data.repo <- paste0(AWAP_directory, "precip/total/r005/01day/")
               file_prefix <- "agcd_v1_precip_total_r005_daily_"
               
               min_year <- 1900
               valid_years <- data_years[data_years >= min_year]
               
          } else if (var == "tmax") {
               
               awap.data.repo <- paste0(AWAP_directory, "tmax/mean/r005/01day/")
               file_prefix <- "agcd_v1_tmax_mean_r005_daily_"
               
               min_year <- 1910
               valid_years <- data_years[data_years >= min_year]
               
          } else if (var == "tmin") {
               
               awap.data.repo <- paste0(AWAP_directory, "tmin/mean/r005/01day/")
               file_prefix <- "agcd_v1_tmin_mean_r005_daily_"
               
               min_year <- 1910
               valid_years <- data_years[data_years >= min_year]
               
          } else if (var == "vapourpres_h09") {
               
               awap.data.repo <- paste0(AWAP_directory, "vapourpres_h09/mean/r005/01day/")
               file_prefix <- "agcd_v1_vapourpres_h09_mean_r005_daily_"
               
               min_year <- 1971
               valid_years <- data_years[data_years >= min_year]
               
          } else if (var == "vapourpres_h15") {
               
               awap.data.repo <- paste0(AWAP_directory, "vapourpres_h15/mean/r005/01day/")
               file_prefix <- "agcd_v1_vapourpres_h15_mean_r005_daily_"
               
               min_year <- 1971
               valid_years <- data_years[data_years >= min_year]
          }
          #----
          
          
          
          # printing messages of valid years to be iterated over   ----
          if(length(valid_years) == 0) {
               message(paste0("No data available for variable: ", var, " for user defined period.
                            First Data Available for ", var, " from ", min_year, "."))
                             cat("\n")
               
          } else if (length(valid_years) < length(data_years)) {
               message(paste0("No data available for variable: ", var, " until ", min_year, "
                            First Data Available for ", var, " from ", min_year, "."))
                             cat("\n")
               
          } else if (length(valid_years) == length(data_years)) {
               message(paste0("Data available for all user defined years for ", var, "."))
                             cat("\n")
          }
          #----
          
          
          # printing Message of All Files to be Downloaded for this Variable:
          message(paste0("For ", var, ", data to be downloaded for the following years: ", paste(valid_years, collapse = ", ")))
                             cat("\n")

          # iterating over years and downloading data  ----
          for (i in valid_years) { 
               
               # Making a download URL
               download_url <- paste0(awap.data.repo, file_prefix, i, ".nc")
               
               # Making a filename for each download:
               output_filename <- paste0(var.output_dir, "/", var, "_", i, "_raw.nc")
          
               # Check if full file already exists    ----
               if(file.exists(output_filename) & !overwrite_download) {
                  message(paste0("Full file already exists for ", i, " (", var, "). Skipping download. Set overwrite=TRUE to re-download."))
                             cat("\n")
               } else {
                  
                  # Actually Downloading The Files but using a trycatch error handler:
                  tryCatch({
                     curl_download(download_url, output_filename)
                     message(paste0("Data from ", i, " downloaded for ", var, "."))
                             cat("\n")
                     
                  }, error = function(e) {
                     message(paste0("Error downloading data from ", i, " for ", var, ": ", e$message))
                             cat("\n")
                  })
               }
               #----
               
               
               # Define cropped + reprojected filenames
                  processed_filename <- file.path(var.processed_dir, paste0(var, "_", i, "_processed.nc"))
               
                  
                  # Skip processing if crop file already exists and overwrite_crop=FALSE
                  # Skip processing if crop file already exists and overwrite_crop=FALSE
                  if (file.exists(processed_filename) && !overwrite_crop) {
                    message("Using existing cropped file: ", processed_filename)
                             cat("\n")
                  } else {
                    message(">>>> Processing year ", i, " (", var, ")")
                             cat("\n")
                        
                  if (!file.exists(output_filename)) {
                    message("Skipping processing for ", var, " ", i, " because raw file is missing.")
                             cat("\n")
                    next
                  }
                  
                    tryCatch({
                      r <- terra::rast(output_filename)
                  
                      # Reproject first (all AWAP data are EPSG:4283, but standardise to WGS84 EPSG:4326)
                      message("Reprojecting ", var, " ", i, " to WGS84...")
                             cat("\n")
                      r <- terra::project(r, "EPSG:4326")
                  
                      # Crop using user shapefile
                      message("Cropping ", var, " ", i, " to region of interest...")
                             cat("\n")
                      r <- terra::crop(r, crop_shape, mask = TRUE)
                  
                      # Save cropped + reprojected
                      terra::writeCDF(r, filename = processed_filename, varname = var, timename = "time", overwrite = TRUE, compression = 4)
                  
                      message("Finished cropping + reprojecting ", var, " ", i)
                             cat("\n")
                  
                      rm(r)
                      invisible(gc())
                    }, error = function(e) {
                      message("Error processing ", var, " ", i, ": ", e$message)
                             cat("\n")
                    })
                  }

          }
            
            file.remove(list.files(var.output_dir, pattern = "\\.aux$|\\.aux\\.xml$|\\.json$", full.names = TRUE))
     }
        message("\n=== Download Complete ===")
                             cat("\n")
}



```


```{r Test Run of Function}

# Test Run:
download_AWAP_clim.data(2019, 2020, 1, c("tmin", "tmax"), "github/clim_data", crop_shape = "github/region_shapefile/Raster_Crop_Extent.shp",
                        overwrite_download = FALSE, overwrite_crop = TRUE)


```

#. 



# download_SILO_clim.data


This function downloads and processses annual raster grids from the SILO climate dataset for user specified years.

The function also reprojects all rasters to CRS 4326 and crops rasters to reduce downstream computational load, using a user supplied shapefile to encompass the region where data is needed.

Files are automatically saved to directories based on which variable they document, their state (direct download or cropped/reprojected).

```{r function for downloading Climate Data from SILO Data drill}


# Function INPUT DATA     ----


#    -    first_year                -  the first year from which to download the data


#...............................................................................................................................................................................


#    -    last_year                 -  the last year from which to download the data


#...............................................................................................................................................................................


#    -    year_interval             -  the interval between years (i.e. 1 = every year, 2 = every second year, 10 = once a decade, etc.)


#...............................................................................................................................................................................


#    -    silo_clim.var             -  a string of variable names which match those used by SILO database
                                             # VARIABLES AVAILABLE FROM THE  SILO DATABASE:
                                             #..............................................................................
                                             # Precipitation                         =  "daily_rain"               From 1889
                                             # Maximum Temperature                   =  "max_temp"                 From 1889
                                             # Minimum Temperature                   =  "min_temp"                 From 1889
                                             # Vapour Pressure                       =  "vp"                       From 1889
                                             # Vapour Pressure deficit               =  "vp_deficit"               From 1889
                                             # Class A pan evaporation               =  "evap_pan"                 From 1889
                                             # Synthetic Estimate                    =  "evap_syn"                 From 1889
                                             # Combination Esimate                   =  "evap_comb"                From 1889
                                             # Morton Shallow Lake Evap              =  "evap_morton_lake"         From 1889
                                             # solar radiation                       =  "radiation"                From 1889
                                             # relative humidity at time of max T    =  "rh_tmax"                  From 1889
                                             # relative humidity at time of min T    =  "rh_tmin"                  From 1889
                                             # FAO56 Short Crop                      =  "et_short_crop"            From 1889
                                             # ASCE tall crop                        =  "et_tall_crop"             From 1889
                                             # Morton's areal actual evapotrans      =  "et_morton_actual"         From 1889
                                             # Mortons point potential evapotrans    =  "et_morton_potential"      From 1889
                                             # Mortons Wet Env Area potential        =  "et_morton_wet"            From 1889
                                             # mean sea level pressure               =  "mslp"                     From 1889


#...............................................................................................................................................................................


#    -    directory                 -  the file directory to save the downloaded data (formatted as "../folder1/subfolder")
#                                         -  direct downloads will be saved to a subdirectory called "raw"
#                                         -  cropped and reprojected files will be saved to a subdirectory called "processed"


#...............................................................................................................................................................................


#    -    overwrite_download        -  whether or not to to overwrite existing direct downloaded year raster files with new downloads
#                                         -  default = FALSE
#                                         -  If FALSE and the file already exists, 
#                                                           the function will either crop (if the file exists and the "overwrite_crop" option is TRUE)
#                                                            or move onto the next year for that variable. 


#...............................................................................................................................................................................


#    -    crop_shape                -   a Shapefile of a polygon which entirely encompasses the desired region for sampling
#                                                                       used to crop the rasters after downloading to reduce file size. 
#                                         -  User Must ensure that the polygon is valid and in CRS: 4326
#                                         -  In order to preserve all required datapoint, the polygon should have a margin of a few cells from the first cell actually needed
#                                                     as slight mismatches between climate databases with regard to raster extent can cause issues downstream. 


#...............................................................................................................................................................................


#    -    overwrite_download        -  whether or not to to overwrite existing direct downloaded year raster files with new downloads
#                                         -  Default = FALSE
#                                         -  If FALSE and the file already exists, 
#                                                            the function will either crop (if the file exists and the "overwrite_crop" option is TRUE)
#                                                             or move onto the next year for that variable. 
#                                         -  If TRUE, then all downloads will be overwritten with new downloads. 


#...............................................................................................................................................................................


#    -    overwrite_crop            -  whether or not to overwrite existing cropped raster files which new cropped raster files from existing uncropped downloads. 
#                                         -  default = FALSE
#                                         -  If FALSE and the cropped files already exist, then the function will move onto the next
#                                         -  If FALSE but the cropped files don't exist, new cropped files will be produced. 
#                                         -  If TRUE, then all files will be cropped and saved. 

#----


download_SILO_clim.data <- function(first_year, last_year, year_interval, silo_clim.var, directory, crop_shape, overwrite_download = FALSE, overwrite_crop = FALSE){
     
     # Ensuring Packages are Loaded:
     library(curl)
      library(terra)
     
     # Defining the year to iterate the function over to download the required climate data:
     data_years <- seq(from = first_year, to = last_year, by = year_interval)
     
     
     # Check for Function    ----
     
     # Ensuring User Defined first year is not earlier than the first year from which climate data is available from  SILO
     if(first_year < 1889) {
          stop("First Year of Climate Data Available from SILO = 1889")
                             cat("\n")
     }
     
     # Ensuring that the year interval is not less than 1
     if(year_interval < 1) {
          stop("Minimum Year Interval is 1")
                             cat("\n")
     }

     
     # Ensuring that the first year is not later than the last year:
     if(first_year > last_year) {
          stop("First Year must be at least 1 year prior to last year")
                             cat("\n")
     }
     
     
     # If crop_shape is a filepath, read it in
      if (is.character(crop_shape)) {
        if (!file.exists(crop_shape)) {
          stop("The crop_shape file path does not exist: ", crop_shape)
                                cat("\n")
        }
        crop_shape <- terra::vect(crop_shape)
      } else if (!inherits(crop_shape, c("SpatVector", "SpatRaster"))) {
        stop("crop_shape must be a terra SpatVector, SpatRaster, or a valid file path")
                              cat("\n")
      }
     #----
     
     
     # VARIABLES AVAILABLE FROM THE  SILO DATABASE:
     # Precipitation                         =  "daily_rain"               From 1889
     # Maximum Temperature                   =  "max_temp"                 From 1889
     # Minimum Temperature                   =  "min_temp"                 From 1889
     # Vapour Pressure                       =  "vp"                       From 1889
     # Vapour Pressure deficit               =  "vp_deficit"               From 1889
     # Class A pan evaporation               =  "evap_pan"                 From 1889
     # Synthetic Estimate                    =  "evap_syn"                 From 1889
     # Combination Esimate                   =  "evap_comb"                From 1889
     # Morton Shallow Lake Evap              =  "evap_morton_lake"         From 1889
     # solar radiation                       =  "radiation"                From 1889
     # relative humidity at time of max T    =  "rh_tmax"                  From 1889
     # relative humidity at time of min T    =  "rh_tmin"                  From 1889
     # FAO56 Short Crop                      =  "et_short_crop"            From 1889
     # ASCE tall crop                        =  "et_tall_crop"             From 1889
     # Morton's areal actual evapotrans      =  "et_morton_actual"         From 1889
     # Mortons point potential evapotrans    =  "et_morton_potential"      From 1889
     # Mortons Wet Env Area potential        =  "et_morton_wet"            From 1889
     # mean sea level pressure               =  "mslp"                     From 1889
     
     
     # Checking that the user defined variables match those used by the  SILO database  ----
     # List of acceptable variable names:
     true_var.names <- c("daily_rain", "max_temp", "min_temp", "vp", "vp_deficit", 
                         "evap_pan", "evap_syn", "evap_comb", "evap_morton_lake", "radiation", 
                         "rh_tmax", "rh_tmin", "et_short_crop", "et_tall_crop", "et_morton_actual", 
                         "et_morton_potential", "et_morton_wet", "mslp")
     
     # Checking that all variables defined by the user are within the list of "true variable names"
     invalid_var.names <- silo_clim.var[!silo_clim.var %in% true_var.names]
     
     if(length(invalid_var.names) > 0) {
          # if the user defined variables are not present then the function will stop and force an error:
          stop(paste0("User Selected Variable Names Not Matching to SILO Names. 
               
               Invalid Variable Names:", paste(invalid_var.names, collapse = ", ")))
                             cat("\n")
     }
     #----
     
     
     # Defining the database Central directory:
     SILO_directory <- "https://s3-ap-southeast-2.amazonaws.com/silo-open-data/Official/annual/"
     
     
     # Looping through each variable
     for (var in silo_clim.var) {  
          
          # Creating output folders for each of the selected variables. ----
            var.output_dir <- paste0(directory, "/", var, "/raw")
            dir.create(var.output_dir, recursive = TRUE, showWarnings = FALSE)
            
            # Output folder for processed (cropped + reprojected) files
            var.processed_dir <- paste0(directory, "/", var, "/processed")
            dir.create(var.processed_dir, recursive = TRUE, showWarnings = FALSE)
          
          
          # Defining the directory for each variable:
          silo.data.repo <- paste0(SILO_directory, var, "/")
          
          
          # printing Message of All Files to be Downloaded for this Variable:
          message(paste0("For ", var, ", data to be downloaded for the following years: ",
                                                            paste(data_years, collapse = ", ")))
                            cat("\n")

          # iterating over years and downloading data  ----
          for (i in data_years) { 
               
               # Defining the filename
               filename <- paste0(i, ".", var, ".nc")
               
               # Making a download URL
               download_url <- paste0(silo.data.repo, filename)
               
               # Making a filename for each download:
               output_filename <- paste0(var.output_dir, "/", var, "_", i, "_raw.nc")
               
               
               # Check if full file already exists    ----
               if(file.exists(output_filename) & !overwrite_download) {
                 message(paste0("Full file already exists for ", i, " (", var, "). Skipping download. Set overwrite=TRUE to re-download."))
                                       cat("\n")
                 } else {
                   
                   # Actually Downloading The Files but using a trycatch error handler:
                   tryCatch({
                     curl_download(download_url, output_filename)
                     message(paste0("Data from ", i, " downloaded for ", var, "."))
                                           cat("\n")
                     
                     }, error = function(e) {
                       message(paste0("Error downloading data from ", i, " for ", var, ": ", e$message))
                                             cat("\n")
                     })
                 }
               #----

               # Define cropped + reprojected filenames
                  processed_filename <- file.path(var.processed_dir, paste0(var, "_", i, "_processed.nc"))
               
                  
                  # Skip processing if crop file already exists and overwrite_crop=FALSE
                  if (file.exists(processed_filename) && !overwrite_crop) {
                    message("Using existing cropped file: ", processed_filename)
                                          cat("\n")
                  } else {
                    message(">>>> Processing year ", i, " (", var, ")")
                                          cat("\n")
                        
                  if (!file.exists(output_filename)) {
                    message("Skipping processing for ", var, " ", i, " because raw file is missing.")
                                          cat("\n")
                    next
                  }
                        
                        
                    tryCatch({
                      r <- terra::rast(output_filename)
                  
                      # Reproject first (all AWAP data are EPSG:4283, but standardise to WGS84 EPSG:4326)
                      message("Reprojecting ", var, " ", i, " to WGS84...")
                                        cat("\n")
                      r <- terra::project(r, "EPSG:4326")
                  
                      # Crop using user shapefile
                      message("Cropping ", var, " ", i, " to region of interest...")
                                        cat("\n")
                      r <- terra::crop(r, crop_shape, mask = TRUE)
                  
                      # Save cropped + reprojected
                      terra::writeCDF(r, filename = processed_filename, varname = var, timename = "time", overwrite = TRUE, compression = 4)
                  
                      message("Finished cropping + reprojecting ", var, " ", i)
                                        cat("\n")
                  
                      rm(r)
                      invisible(gc())
                    }, error = function(e) {
                      message("Error processing ", var, " ", i, ": ", e$message)
                                            cat("\n")
                    })
                  }

          }
            
            file.remove(list.files(var.output_dir, pattern = "\\.aux$|\\.aux\\.xml$|\\.json$", full.names = TRUE))
     }
        message("\n=== Download Complete ===")
                       cat("\n")
}

```


```{r testing function}


# Test Run:
download_SILO_clim.data(2019, 2020, 1, c("radiation", "daily_rain"), "github/clim_data", crop_shape = "github/region_shapefile/Raster_Crop_Extent.shp",
                        overwrite_download = FALSE, overwrite_crop = TRUE)

```

#. 



# download_ANUCLIM_clim.data

This function downloads and processses annual raster grids from the ANUClimate 2.0 climate dataset for user specified years.

Downloads from ANUClimate 2.0 are monthly and therefore to make them compatible with SILO and AWAP rasters for ease of downstream processing, the function downloads these files as "monthly" to a directory, before further processing and compiling. 

Monthly files are then reprojected to CRS:4326, cropped to a user defined shapefile to reduce file size and computational load and then saved as to a "monthly_processed" directory. 

These "monthly_processed" files are then compiled to a single, annualised raster file, in the "processed" sub-directory. 

The function also reprojects all rasters to CRS 4326 and crops rasters to reduce downstream computational load, using a user supplied shapefile to encompass the region where data is needed.

Files are automatically saved to directories based on which variable they document, their state (direct download (monthly), or cropped/reprojected).

```{r function for downloading Climate Data from ANUCLIM}

# Function INPUT DATA     ----


#    -    first_year                -  the first year from which to download the data


#...............................................................................................................................................................................


#    -    last_year                 -  the last year from which to download the data


#...............................................................................................................................................................................


#    -    year_interval             -  the interval between years (i.e. 1 = every year, 2 = every second year, 10 = once a decade, etc.)


#...............................................................................................................................................................................


#    -    anuclim_clim.var          -  a string of variable names which match those used by SILO database
                                              # VARIABLES AVAILABLE FROM THE ANUCLIM DATABASE:
                                              #..............................................................................
                                              # Class A Pan Evaporation          =  "evap"               From 1970
                                              # Precipitation                    =  "rain"               From 1900
                                              # Radiation                        =  "srad"               From 1960
                                              # Average Temperature              =  "tavg"               From 1960
                                              # Maximum Temperature              =  "tmax"               From 1960
                                              # Minimum Temperature              =  "tmin"               From 1960
                                              # Vapour Pressure                  =  "vp"                 From 1960
                                              # Vapour Pressure Deficit          =  "vpd"                From 1960


#...............................................................................................................................................................................


#    -    directory                 -  the file directory to save the downloaded data (formatted as "../folder1/subfolder")
#                                         -  direct downloads will be saved to a subdirectory called "raw"
#                                         -  cropped and reprojected files will be saved to a subdirectory called "processed"


#...............................................................................................................................................................................


#    -    overwrite_download        -  whether or not to to overwrite existing direct downloaded year raster files with new downloads
#                                         -  default = FALSE
#                                         -  If FALSE and the file already exists, 
#                                                           the function will either crop (if the file exists and the "overwrite_crop" option is TRUE)
#                                                            or move onto the next year for that variable. 


#...............................................................................................................................................................................


#    -    crop_shape                -   a Shapefile of a polygon which entirely encompasses the desired region for sampling
#                                                                       used to crop the rasters after downloading to reduce file size. 
#                                         -  User Must ensure that the polygon is valid and in CRS: 4326
#                                         -  In order to preserve all required datapoint, the polygon should have a margin of a few cells from the first cell actually needed
#                                                     as slight mismatches between climate databases with regard to raster extent can cause issues downstream. 


#...............................................................................................................................................................................


#    -    overwrite_download        -  whether or not to to overwrite existing direct downloaded year raster files with new downloads
#                                         -  Default = FALSE
#                                         -  If FALSE and the file already exists, 
#                                                            the function will either crop (if the file exists and the "overwrite_crop" option is TRUE)
#                                                             or move onto the next year for that variable. 
#                                         -  If TRUE, then all downloads will be overwritten with new downloads. 


#...............................................................................................................................................................................


#    -    overwrite_crop            -  whether or not to overwrite existing cropped raster files with new cropped raster files from existing unprocessed downloads. 
#                                         -  default = FALSE
#                                         -  If FALSE and the cropped files already exist, then the function will move onto the next
#                                         -  If FALSE but the cropped files don't exist, new cropped files will be produced. 
#                                         -  If TRUE, then all files will be cropped and saved. 


#...............................................................................................................................................................................


#    -    overwrite_compile         -  whether or not to overwrite existing compiled annual raster files with new cropped raster files from existing processed monthly files
#                                         -  default = FALSE
#                                         -  If FALSE and the annualized processed file already exist, then the function will move onto the next
#                                         -  If FALSE but the annualized processed file don't exist, processed monthly files for that year will be compiled to an annual file
#                                         -  If TRUE, then all monthly files will be compiled to annualised files. 

#----


download_ANUCLIM_clim.data <- function(first_year, last_year, year_interval, anuclim_clim.var, directory, crop_shape,
                                       overwrite_download = FALSE, overwrite_crop = FALSE, overwrite_compile = FALSE) {
   
   # Ensuring Packages are Loaded:
   library(curl)
   library(terra)
   library(lubridate)
   
   
   # Defining the year to iterate the function over to download the required climate data:
   data_years <- seq(from = first_year, to = last_year, by = year_interval)
   
   
   # Check for Function    ----
   
   # Ensuring User Defined first year is not earlier than the first year from which climate data is available from ANUCLIM
   if(first_year < 1900) {
      stop("First Year of Climate Data Available from ANUCLIM = 1900")
                                cat("\n")
   }
   
   # Ensuring that the year interval is not less than 1
   if(year_interval < 1) {
      stop("Minimum Year Interval is 1")
                                cat("\n")
   }
   
   
   # Ensuring that the first year is not later than the last year:
   if(first_year > last_year) {
      stop("First Year must be at least 1 year prior to last year")
                                cat("\n")
   }
   
   # If crop_shape is a filepath, read it in
      if (is.character(crop_shape)) {
        if (!file.exists(crop_shape)) {
          stop("The crop_shape file path does not exist: ", crop_shape)
                                cat("\n")
        }
        crop_shape <- terra::vect(crop_shape)
      } else if (!inherits(crop_shape, c("SpatVector", "SpatRaster"))) {
        stop("crop_shape must be a terra SpatVector, SpatRaster, or a valid file path")
                                cat("\n")
      }
   #----
   
   
   # VARIABLES AVAILABLE FROM THE ANUCLIM DATABASE:
   # Class A Pan Evaporation          =  "evap"               From 1970
   # Precipitation                    =  "rain"               From 1900
   # Radiation                        =  "srad"               From 1960
   # Average Temperature              =  "tavg"               From 1960
   # Maximum Temperature              =  "tmax"               From 1960
   # Minimum Temperature              =  "tmin"               From 1960
   # Vapour Pressure                  =  "vp"                 From 1960
   # Vapour Pressure Deficit          =  "vpd"                From 1960
   
   # Checking that the user defined variables match those used by the ANUCLIM database  ----
   # List of acceptable variable names:
   true_var.names <- c("evap", "rain", "srad", "tavg", "tmax", "tmin", "vp", "vpd")
   
   # Checking that all variables defined by the user are within the list of "true variable names"
   invalid_var.names <- anuclim_clim.var[!anuclim_clim.var %in% true_var.names]
   
   if(length(invalid_var.names) > 0) {
      # if the user defined variables are not present then the function will stop and force an error:
      stop(paste0("User Selected Variable Names Not Matching to ANUCLIM Names. 
               
               Invalid Variable Names:", paste(invalid_var.names, collapse = ", ")))
   }
   #----
   
   
   # Defining the database Central directory:
   ANUCLIM_directory <- "https://thredds.nci.org.au/thredds/fileServer/gh70/ANUClimate/v2-0/stable/day/"
   
   
   # Looping through each variable
   for (var in anuclim_clim.var) {  
      
      # Renaming tmin and tmax to avoid overlaps with the AWAP dataset:
      if (var == "tmin") {
          out_var <- "t_min"
      } else if (var == "tmax") {
          out_var <- "t_max"
      } else {
          out_var <- var
      }
     
     
     
      
      # Creating output folders for each of the selected variables. ----
         var.monthly_dir <- paste0(directory, "/", out_var, "/monthly")
         var.processed_dir <- paste0(directory, "/", out_var, "/processed")
         dir.create(var.monthly_dir, recursive = TRUE, showWarnings = FALSE)
         dir.create(var.processed_dir, recursive = TRUE, showWarnings = FALSE)
         # Create folder for cropped monthly rasters
         var.monthly_processed_dir <- file.path(directory, out_var, "monthly_processed")
         dir.create(var.monthly_processed_dir, recursive = TRUE, showWarnings = FALSE)
      #----
      


      
      
      # Defining the repository depending on the climate data:
      # Also defining valid year for each variable      ----
      if(var == "evap") {
         
         anuclim.data.repo <- paste0(ANUCLIM_directory, var, "/")
         file_prefix <- paste0("ANUClimate_v2-0_", var, "_daily_")
         
         min_year <- 1970
         valid_years <- data_years[data_years >= min_year]
         
      } else if (var == "rain") {
         
         anuclim.data.repo <- paste0(ANUCLIM_directory, var, "/")
         file_prefix <- paste0("ANUClimate_v2-0_", var, "_daily_")
         
         min_year <- 1900
         valid_years <- data_years[data_years >= min_year]
         
      } else if (var == "srad") {
         
         anuclim.data.repo <- paste0(ANUCLIM_directory, var, "/")
         file_prefix <- paste0("ANUClimate_v2-0_", var, "_daily_")
         
         min_year <- 1960
         valid_years <- data_years[data_years >= min_year]
         
      } else if (var == "tavg") {
         
         anuclim.data.repo <- paste0(ANUCLIM_directory, var, "/")
         file_prefix <- paste0("ANUClimate_v2-0_", var, "_daily_")
         
         min_year <- 1960
         valid_years <- data_years[data_years >= min_year]
         
      } else if (var == "tmax") {
         
         anuclim.data.repo <- paste0(ANUCLIM_directory, var, "/")
         file_prefix <- paste0("ANUClimate_v2-0_", var, "_daily_")
         
         min_year <- 1960
         valid_years <- data_years[data_years >= min_year]
         
      } else if (var == "tmin") {
         
         anuclim.data.repo <- paste0(ANUCLIM_directory, var, "/")
         file_prefix <- paste0("ANUClimate_v2-0_", var, "_daily_")
         
         min_year <- 1960
         valid_years <- data_years[data_years >= min_year]
         
      } else if (var == "vp") {
         
         anuclim.data.repo <- paste0(ANUCLIM_directory, var, "/")
         file_prefix <- paste0("ANUClimate_v2-0_", var, "_daily_")
         
         min_year <- 1960
         valid_years <- data_years[data_years >= min_year]
         
      } else if (var == "vpd") {
         
         anuclim.data.repo <- paste0(ANUCLIM_directory, var, "/")
         file_prefix <- paste0("ANUClimate_v2-0_", var, "_daily_")
         
         min_year <- 1960
         valid_years <- data_years[data_years >= min_year]
      }
      #----
      
      
      
      # printing messages of valid years to be iterated over   ----
      if(length(valid_years) == 0) {
         print(paste0("No data available for variable: ", out_var, " for user defined period.
                            First Data Available for ", out_var, " from ", min_year, "."))
                                cat("\n")
         
      } else if (length(valid_years) < length(data_years)) {
         print(paste0("No data available for variable: ", out_var, " until ", min_year, "
                            First Data Available for ", out_var, " from ", min_year, "."))
                                cat("\n")
         
      } else if (length(valid_years) == length(data_years)) {
         print(paste0("Data available for all user defined years for ", out_var, "."))
                                cat("\n")
      }
      #----
      
      
      # printing Message of All Files to be Downloaded for this Variable:
      message(paste0("For ", out_var, ", data to be downloaded for the following years: ", paste(valid_years, collapse = ", ")))
                                cat("\n")
      
      # iterating over years and downloading data  ----
      for (i in valid_years) { 

         
         
         # Defining the output filename for the final file:
         output_filename <- paste0(var.processed_dir, "/", out_var, "_", i, "_processed.nc")
         
         
            # Check if we should skip this entire year
            skip_year <- file.exists(output_filename) & !overwrite_compile
            
            if(skip_year) {
               message(paste0("Annual file already exists for ", i, " (", out_var, "). Skipping year. Set overwrite_compile=TRUE to re-process."))
                  cat("\n")
            }
            
            
            # if we are not skipping the year
            if(!skip_year) { 
            
            # Looping through the months for each year   ----
            for (month in 1:12) {
               
               # Format month with leading zero
               month_str <- sprintf("%02d", month)
               
               # Making a download URL for this month
               download_url <- paste0(anuclim.data.repo, i, "/", file_prefix, i, month_str, ".nc")
               
               
               # Making a filename for this monthly download
               monthly_filename <- paste0(var.monthly_dir, "/", out_var, "_", i, "_", month_str, "_monthly.nc")
               
               
               # Check if full file already exists    ----
               if(file.exists(monthly_filename) & !overwrite_download) {
                  message(paste0("Monthly file already exists for month: ", month_str, " of year: ", i, " (", out_var, "). Skipping download.", "\n",
                                 "Set overwrite_download = TRUE to re-download."))
                     cat("\n")
               } else {
                  # Actually Downloading The Files but using a trycatch error handler:
                  tryCatch({
                     print(paste0("Downloading:  Month = ", month_str, "  |  Year = ", i, "  |  Var = ", var))
                     curl_download(download_url, monthly_filename)
                     message(paste0("Month ", month_str, " of ", i, " downloaded for ", out_var, "."))
                     cat("\n")
                     
                  }, error = function(e) {
                     message(paste0("Error downloading month ", month_str, " of ", i, " for ", out_var, ": ", e$message))
                        cat("\n")
                  })
               } # End of Monthly file conditional check - for the sub-files from ANUCLIM - for monthly data
               
               
            } # End of Loop through months
         } # End of Full File conditional check - for the compiled "FULL" raster   
         
         #----

            
         # Merging All monthly files into a single Raster file     ----
         if(!skip_year) {
         tryCatch({
            
            # List all monthly files for this year
            monthly_files <- list.files(var.monthly_dir,
                                        pattern = paste0(out_var, "_", i, "_\\d{2}_monthly\\.nc"),
                                        full.names = TRUE)
            monthly_files <- sort(monthly_files)   # ensure 01,02,...12 ordering
            
            # Guard: ensure exactly 12 files exist and they are unique
            monthly_files <- unique(monthly_files)
            if (length(monthly_files) != 12) {
              message("Found ", length(monthly_files), " monthly files for ", i, " (", out_var, "). Expected 12. Skipping compile.")
                  cat("\n")
              next   # continue to next year
            }
               
            if(length(monthly_files) == 12) {
                  
                  
                  # For each month, get expected days
                  days_in_month <- if(leap_year(i)) c(31,29,31,30,31,30,31,31,30,31,30,31) else c(31,28,31,30,31,30,31,31,30,31,30,31)
                  
                  for(m in 1:12){
                    r <- terra::rast(monthly_files[m])
                    if(nlyr(r) != days_in_month[m]){
                      warning(paste0("Month ", sprintf("%02d", m), " of year ", i, " has ", nlyr(r), 
                                     " layers, expected ", days_in_month[m], ". Skipping this year."))
                          cat("\n")
                      next_year_flag <- TRUE
                      break
                    }
                  }
                  if(exists("next_year_flag") && next_year_flag) { rm(next_year_flag); next }
                  
                  
                  # Creating a stack of rasters
                  monthly_stacks <- lapply(monthly_files, function(f) {
                  
                      # Define cropped file path
                      cropped_file <- file.path(var.monthly_processed_dir, basename(gsub("_monthly\\.nc$", "_processed_month.nc", f)))
                  
                      # If cropped file exists and overwrite_crop = FALSE, use it
                      if(file.exists(cropped_file) && !overwrite_crop) {
                          r <- terra::rast(cropped_file)
                          message(paste0("Using existing cropped file: ", basename(cropped_file)))
                      } else {
                          # Otherwise, read original monthly file and crop
                          r <- terra::rast(f)
                  
                          # Crop and mask using the shapefile
                          if(!same.crs(r, crop_shape)) {
                              shape_reproj <- project(crop_shape, crs(r))
                          } else {
                              shape_reproj <- crop_shape
                          }
                  
                          r <- crop(r, shape_reproj)
                          r <- mask(r, shape_reproj)
                  
                          # Save cropped raster
                          writeRaster(r, cropped_file, overwrite = TRUE)
                          message(paste0("Created new cropped file: ", basename(cropped_file)))
                      }
                  
                      return(r)
                  })
                  annual_stack <- do.call(c, monthly_stacks)

                  # optional: simple message instead of pb
                  message("Loaded ", length(monthly_files), " monthly files for ", i, " (", out_var, ")")
                  cat("\n")
               
               
               # Extracting day information from rasters and verifying it
               start_date <- as.Date(paste0(i, "-01-01"))
               n_days_expected <- ifelse(leap_year(i), 366, 365)
                  n_days_actual <- terra::nlyr(annual_stack)

               # Verify layer count matches expected days
               if(n_days_actual != n_days_expected) {
                  warning(paste0("Layer count mismatch for ", i, " (", out_var, "): expected ", n_days_expected, ", got ", n_days_actual))
                     cat("\n")
               }
               
               # Creating a sequence of dates based on ACTUAL layer count
               date_seq <- seq.Date(from = start_date, by = "day", length.out = n_days_actual)
               
                  if(length(date_seq) == n_days_actual) {
                    names(annual_stack) <- as.character(date_seq)
                    terra::time(annual_stack) <- date_seq
                  } else {
                    warning("Cannot assign names to annual stack: layer count mismatch.")
                        cat("\n")
                    next
                  }
               
               
               # Renaming tmin and tmax to avoid overlaps with the AWAP dataset:
               if (var == "tmin") {
                 message("ANUCLIM climate variable: 'tmin' has been renamed to 't_min' to avoid conflicts with 'tmin' from BOM AWAP Climate Data")
                     cat("\n")
               } else if (var == "tmax") {
                 message("ANUCLIM climate variable: 'tmax' has been renamed to 't_max' to avoid conflicts with 'tmax' from BOM AWAP Climate Data")
                     cat("\n")
               }
               
               # Save as single annual NetCDF file
               output_filename <- paste0(var.processed_dir, "/", out_var, "_", i, "_processed.nc")
               
               message(">>>> Projecting Raster to WGS84 (EPSG:4326")
               annual_stack <- terra::project(annual_stack, "EPSG:4326")
               
               message(">>>> Starting writeCDF for ", out_var, " ", i)
               terra::writeCDF(annual_stack, filename = output_filename, varname = out_var, timename = "time", overwrite = overwrite_compile, compression = 4)
               message(">>>> Finished writeCDF for ", out_var, " ", i)
               message(paste0("Annual file for ", i, " created for ", out_var, " (", terra::nlyr(annual_stack), " days)."))
               
                  # Clean up but avoid forcing a long synchronous gc() immediately after write
                  rm(annual_stack, monthly_files)
                  # close general R connections (not terra-specific, but helpful)
                  try(closeAllConnections(), silent = TRUE)
                  # call gc but keep messages minimal  this usually frees netcdf handles
                  invisible(gc())
                  
                  message("Cleaned up objects and freed memory for ", out_var, " ", i)
                  cat("\n")
               
            } else {
               message(paste0("Warning: Only ", length(monthly_files), " of 12 months downloaded for ", i, " (", out_var, "). Annual file not created."))
                  cat("\n")
            }
            
         }, error = function(e) {
            message(paste0("Error merging monthly files for ", i, " (", out_var, "): ", e$message))
               cat("\n")
         })
               
         }
            
      } # End of Loop through Years
      
      file.remove(list.files(var.processed_dir, pattern="\\.aux$|\\.aux\\.xml$|\\.json$", full.names=TRUE))
      
   } #End of Loop through variables
      message("\n=== Download Complete ===")
      
}


```



```{r Testing Function}


# Test Run:
download_ANUCLIM_clim.data(first_year = 2019, last_year = 2020, year_interval = 1, 
                           anuclim_clim.var = c("tmin", "tmax"), directory = "github/clim_data", crop_shape = "github/region_shapefile/Raster_Crop_Extent.shp",
                           overwrite_download = FALSE, overwrite_compile = T, overwrite_crop = T)


```


#. 



# rescale_align_rasters

Since the SILO and AWAP climate data rasters are at a resolution of 0.05 x 0.05 degrees but the ANUClimate 2.0 files are at 0.01 x 0.01 resolution, the ANUClimate 2.0 data MAY need to be rescaled to match the SILO and AWAP data, depending on the intended downstream use. 

If the user does not intent to use ANUClimate 2.0 data ALONGSIDE SILO and/or AWAP data, then rescaling is not necessary assuming that centroid coordinates supplied to downstream functions are rounded appropriately. 

Howwever, if the user would like to use a combination of ANUClimate and SILO/AWAP variables, for point extraction OR for the construction of map surfaces, then the ANUClimate data must be rescaled to match 0.05x0.05 resolution. 

This is completed via resampling the raster and either summing or averaging the cells to the new resolution:

If the variable being rescaled is precipitation, evaporation or evapotranspiration, the values will be summed to retain a "total" value for the cell.
All other variables are averaged.

The rescaling is completed to match a "template" raster - i.e. one of the either SILO or AWAP rasters to be used alongside the ANUClimate data. 
Since AWAP and SILO have identical scales, even if you are using all three sources of data, only one file is required. 

Rescaled files are automatically saved to a "rescaled" subdirectory within the variable directory

```{r function for rescaling the ANUCLIM data }

# Function INPUT DATA     ----

#    -    var_directories           -  a vector of variable directories containing the ANUClimate files which need to be rescaled. 


#...............................................................................................................................................................................


#    -    template_file             -  the path to a template file - i.e. a "processed" SILO or AWAP file from previous functions.

#----



rescale_align_rasters <- function(var_directories, template_file) {
     
     # Ensuring Packages are Loaded:
     library(terra)
     library(tidyverse)
     
     
     # Input Validation    ----
     
     # Check that template file exists
     if(!file.exists(template_file)) {
          stop("Template file does not exist. Provide a valid SILO or AWAP NetCDF file path.")
                                cat("\n")
     }
     
     # Check that ANUCLIM directories exist
     for(dir in var_directories) {
          if(!dir.exists(dir)) {
               stop(paste0("target directory does not exist: ", dir))
                                cat("\n")
          }
     }
     

     
     
     
     # Load Template Raster to Define Target Grid    ----
     template_raster <- terra::rast(template_file)
     
     message("Target grid specifications:")
     message(paste0("  Resolution: ", res(template_raster)[1], " x ", res(template_raster)[2]))
     message(paste0("  Extent: ", paste(as.vector(terra::ext(template_raster)), collapse = ", ")))
     message(paste0("  CRS: ", crs(template_raster)))
     #----
     

     
     # Process Each ANUCLIM Variable Directory    ----
     for(var_dir in var_directories) {
           
          input_dir <- file.path(var_dir, "processed")  # append 'processed' to parent dir
            if(!dir.exists(input_dir)) {
              warning(paste0("Processed folder does not exist: ", input_dir))
                                cat("\n")
              next
            }
          
          # Extract variable name from directory path
          var_name <- basename(var_dir)
          message(paste0("\nProcessing variable: ", var_name))
          
          
          # Get list of all annual NetCDF files in this directory
          annual_files <- list.files(input_dir, pattern = "\\.nc$", full.names = TRUE)
          
          # Exclude reprojected files
          annual_files <- annual_files[!grepl("rescaled", basename(annual_files))]
          
          if(length(annual_files) == 0) {
               warning(paste0("No files found in: ", input_dir))
                                cat("\n")
               next
          }
          
          message(paste0("  Found ", length(annual_files), " annual files to rescale"))
                                cat("\n")
          
          
          
          # Process each annual file    ----
            for(file_path in annual_files) {
                
                r <- terra::rast(file_path)
                
                # Ensure storing of metadata:
                original_time <- terra::time(r)
                original_names <- names(r)
                
                # Logging progress for the user
                message(paste0("  Processing: ", basename(file_path)))
                message(paste0("    Input resolution: ", res(r)[1], " x ", res(r)[2]))
                message(paste0("    Input layers: ", nlyr(r)))
                                cat("\n")
                
                # Check if the rasters need to be reprojected - they should not as they were all projected to crs:4326
                if(!terra::same.crs(r, template_raster)) {
                    message("    Reprojecting CRS before aggregation...")
                                cat("\n")
                    r <- terra::project(r, crs(template_raster), method = "bilinear")
                }
                
                  # Determining the method of resampling grid cells:
                  # if rainfall or evaporation values, these are summed
                  # # Any other variables are averaged:
                  
                  #  Defining the variables to be summed 
                  evap_rain_var.names <- c("precip", "daily_rain", "rain",
                                           "evap_pan", "evap_syn", "evap_comb", "evap_morton_lake", "evap",
                                           "et_short_crop", "et_tall_crop", "et_morton_lake", "et_morton_potential", "et_morton_wet")
                  
                  # Conditionally resampling raster:
                  if(var_name %in% evap_rain_var.names) {
                      # resample raster cells to compute coarser resolution
                      r_aligned <- terra::resample(r, template_raster, method = "sum")  
                      message("    Using SUM to resample Precipitation, Evaporation and Evapotranspiration Values")
                  } else {
                      # resample raster cells to compute coarser resolution
                      r_aligned <- terra::resample(r, template_raster, method = "average")  
                      message("    Using AVERAGE For All Variables Other than Precipitation, Evaporation and Evapotranspiration")
                  }

                # Restore time metadata
                if(!is.null(original_time) && length(original_time) == nlyr(r_aligned)) {
                    terra::time(r_aligned) <- original_time
                }
                
                # Restore layer names
                if(length(original_names) == nlyr(r_aligned)) {
                    names(r_aligned) <- original_names
                }
                  message(paste0("    Output resolution: ", res(r_aligned)[1], " x ", res(r_aligned)[2]))
                  message(paste0("    Output layers: ", nlyr(r_aligned)))
                
                
                
                # Save reprojected/rescaled raster
                out.dir <- file.path(var_dir, "rescaled")
                dir.create(out.dir, recursive = TRUE, showWarnings = FALSE)
                out_file <- file.path(out.dir, sub("_processed\\.nc$", "_rescaled.nc", basename(file_path)))
                message(paste0("Input: ", basename(file_path), " -> Output: ", basename(out_file)))
                                cat("\n")
                
                # saving the new raster
                terra::writeCDF(r_aligned, out_file, varname = var_name, overwrite = TRUE, compression = 4)
                
                # check if metadata was preserved:
                r_check <- terra::rast(out_file)
                  if(!is.null(original_time) && is.null(terra::time(r_check))) {
                      warning("    Time metadata may not have been preserved in NetCDF")
                                cat("\n")
                  }
                  rm(r_check)
                
                #cleaning the environment
                rm(r, r_aligned)
                gc()
            } 
          
          message(paste0("Reprojected files saved to: ", out.dir))
                                cat("\n")
  }
     
            message("Note: Files were aggregated using cell sums (Precipitation, Evaporation, Evapotranspiration)  OR  cell averages (all other variables).")
            message("      Use these rescaled files when combining with SILO/AWAP data")
}

```


```{r test the function}

# TEST RUN:
rescale_align_rasters(var_directories = c("github/clim_data/t_min", "github/clim_data/t_max"),
                                  template_file = "github/clim_data/daily_rain/processed/daily_rain_2020_processed.nc")

```
#. 




# make_cell_centroids_df 

This function uses a template cropped raster to produce a dataframe of centroids for each cell in the cropped region (method = grid) or for each cell within the region for which a sample was collected (method = sample)

Outputs an RDS file. 

```{r function for creating a polygon of centroids}


# Function INPUT DATA     ----

#    -    template                  -  A single example raster from which the centroids will be computed to the right resolution


#...............................................................................................................................................................................


#    -    sample_df                 -  a dataframe of samples for which the climate data is to be collected. 
#                                         -  Each row should be a unique sample and sample ID  
#                                         -  Must contain the following collumns, named as described:
#                                                -  sample.id    - Sample ID for each sample
#                                                -  lat          - latitude for each sample (rounded to match the target resolution)
#                                                -  lon          - longitude for each sample (rounded to match the target resolution)
#                                         -  Example sample_df:
                                                # 'data.frame':	428 obs. of  16 variables:
                                                #  $ sample_name   : chr  "ANIC-14" "ANIC-16" "ANIC-17" "ANIC-18" ...
                                                #  $ sample_no     : int  14 16 17 18 20 21 22 23 24 25 ...
                                                #  $ subspp        : chr  "Abeona" "Abeona" "Abeona" "Abeona" ...
                                                #  $ sex           : int  1 1 1 1 1 1 1 1 1 1 ...
                                                #  $ measurer      : chr  "" "" "" "" ...
                                                #  $ collection    : chr  "ANIC" "ANIC" "ANIC" "ANIC" ...
                                                #  $ site          : chr  "" "" "" "" ...
                                                #  $ lat           : num  -35.6 -35.6 -35.1 -35.7 -35.7 ...
                                                #  $ lon           : num  150 150 150 150 150 ...
                                                #  $ elev          : int  28 2 605 16 0 869 605 2 30 28 ...
                                                #  $ sampling_date : chr  "22/03/1969" "25/10/1956" "29/11/1962" "22/01/1963" ...
                                                #  $ sampling_year : int  1969 1956 1962 1963 1969 1962 1962 1936 1962 1969 ...
                                                #  $ sampling_month: int  3 10 11 1 10 2 11 10 2 3 ...
                                                #  $ sampling_day  : int  22 25 29 22 4 16 29 25 28 22 ...
                                                #  $ sampling_yrday: int  81 299 333 22 277 47 333 299 59 81 ...
                                                #  $ gen_cycle     : int  -1 1 1 1 1 -1 1 1 -1 -1 ...


#...............................................................................................................................................................................


#    -    method                    -  A character string to determine the method for the function:
#                                         -  "grid"  =  Extracts every centroid for the entire cropped sampling region
#                                         -  "sample"  =  Extracts centroids for the grid cells for which samples are found. 


#...............................................................................................................................................................................


#    -    directory                 -  the directory in which to save the file - file named automatically by the function based on resolution and method. 
#                                         - File saved as a .csv file 


#----


make_cell_centroids_df <- function(template = NULL,
                                   sample_df = NULL,
                                   method = "grid",
                                   directory) {
      
      # Loading Required Packages:
      library(terra)
      library(sf)
      library(tidyverse)
      
      # Function if the user is converting a grid to centroids based on the shapefile;
      if(method == "grid") {
            
      
            if(is.null(template)) {
                  stop("Template Raster Required for Method = Grid ")
            }
      
      # Load in the template raster - Band 1:
      template_rast <- terra::rast(template)
      
      # getting the resolution of the template:
      resolution <- res(template_rast)[1]
      
      
      # Converting each cell to a centroid point
      pts <- as.data.frame(template_rast[[1]], xy = TRUE, na.rm = TRUE)
      
      # Assigning a centroid ID
      centroids_df <- data.frame(centroid.id = 1:nrow(pts), lat = pts$y, lon = pts$x)
            
      # Saving the Object and Returning it to the user:
      write.csv(centroids_df, paste0(directory, "/region.grid_centroids_res=", resolution, ".csv"))
      return(centroids_df)  
            
      
      } else if(method == "sample") {
            
            if(is.null(template)) {
                  stop("Template Raster Required for Method = Sample ")
            }
            
            
            if(is.null(sample_df)) {
                  stop("Sample Locations Required for Method = Sample")
            }
            
            
      # Load in the template raster - Band 1:
      template_rast <- terra::rast(template)
      
      # getting the resolution of the template:
      resolution <- res(template_rast)[1]
      
      
      centroids_df <- sample_df %>%
                                  rename(raw_lat = lat, 
                                         raw_lon = lon)
                                  mutate(lon = round(raw_lat / resolution) * resolution,
                                         lat = round(raw_lat / resolution) * resolution) %>%
                                  distinct(lat, lon) %>%
                                  mutate(centroid.id = row_number())
      
      # Saving the Object and Returning it to the user:
      write.csv(centroids_df, paste0(directory, "/sample_centroids_res=", resolution, ".csv"))
      return(centroids_df)  

      } else {
            stop("Method must be 'grid' or 'sample'")
      }
}


```

```{r testing the function}


ind_meta <- read.csv("test_dataset/Example_metadata.csv")
str(ind_meta)



test.centroids_grid <- make_cell_centroids_df(template = "D:/Mateo/OneDrive - Macquarie University/2 - Tisiphone Abeona Project/Analysis/github/clim_data/daily_rain/processed/daily_rain_2019_processed.nc",
                       sample_df = ind_meta,
                       method = "grid",
                       directory = "test_dataset")

nrow(test.centroids_grid)

```

#. 








# extract_and_compile_clim.data


This function processes rasters from previous functions, extracting climate data for every date for user specified locations, supplied through a dataframe of grid centroids. 

The function extracts data for each grid cell and day, converting it to a long format dataframe where each location has 'z' number of rows, where 'z' is the number of days included in the rasters provided (years x 365 or 366)

Errors may arise here is the user specified shapefile used to crop the rasters earlier in the workflow are too small and result in the exclusion of cells which align with centroids. 
this error results in many NA values - ensure that the shapefile used earlier encompasses slightly more cells than is necessary. 

```{r function for converting the raster data to a dataframe format}

# Function INPUT DATA     ----

#    -    first_year                -  the first year from which to download the data


#...............................................................................................................................................................................


#    -    var_directories           -  a vector to the variable sub-directories which are to be computed from raster to dataframe format


#...............................................................................................................................................................................


#    -    centroid_df               -    the output of the make_cell_centroids_df using method = "grid"
#                                         - Users can use a dataframe produced separately but it must adhere to the below:
#                                         -  NOTE THAT THE coordinates of the centroids MUST be rounded to match the resolution of the rasters being used:
#                                                     - IF using BOM/SILO/Rescaled ANUClim  -  0.05 x 0.05
#                                                     - IF using original resolution ANUClim ONLY  -  0.01 x 0.01
#                                         -  Coordinates to be in CRS 4326 and as decimal degrees
#                                         -  Collumns for coordinates should be named as "lat" and "lon"
#                                         -  Each location should be accompanied with a unique identifier number, with collumn name "centroid_id"
                                                   # Example dataframe:
                                                   #......................
                                                   #        lat      lon    centroid_id
                                                   # 1   -35.00   150.40              1
                                                   # 2   -35.00   150.45              2
                                                   # 3   -35.00   150.50              3
                                                   # 4   -35.00   150.55              4
                                                   # 5   -35.00   150.60              5


#...............................................................................................................................................................................


#    -    output_filepath           -  a path to save the output dataframe as an RDS file (.RDS)


#...............................................................................................................................................................................


#    -    check_crs                 -  if TRUE, checks CRS compatibility and issues warnings


#----


extract_and_compile_clim.data <- function(var_directories,  centroid_df, output_filepath, check_crs = TRUE) {
   
      # Ensuring all required packages are loaded:
      library(sf)
      library(terra)
      library(tidyverse)
      library(lubridate)
      library(data.table)

      
      # Checking user inputs are valid    ----
      
      # Validate centroid_df structure
      required_cols <- c("lat", "lon", "centroid.id")
      missing_cols <- required_cols[!required_cols %in% names(centroid_df)]
      
      if(length(missing_cols) > 0) {
            stop(paste0("centroid_df missing required columns: ", paste(missing_cols, collapse = ", ")))
      }
      
      # Check that coordinates are numeric
      if(!is.numeric(centroid_df$lat) | !is.numeric(centroid_df$lon)) {
            stop("lat and lon columns must be numeric")
      }
      
      # Check coordinate ranges (should be within Australia roughly)
      if(any(centroid_df$lat < -45 | centroid_df$lat > -10)) {
            warning("Some latitude values outside typical Australian range (-45 to -10)")
      }
      if(any(centroid_df$lon < 110 | centroid_df$lon > 155)) {
            warning("Some longitude values outside typical Australian range (110 to 155)")
      }
      
      # Check that directories exist
      for(dir in var_directories) {
            if(!dir.exists(dir)) {
                  stop(paste0("Directory does not exist: ", dir))
            }
      }
      
      # Create output directory if needed
      output_dir <- dirname(output_filepath)
      if(!dir.exists(output_dir)) {
            dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
      }
      
      message(paste0("Processing ", length(var_directories), " climate variables"))
      message(paste0("Extracting data for ", nrow(centroid_df), " locations"))
      #----
      
      
      
      # Prepare spatial points for extraction ----
      centroids_sf <- st_as_sf(centroid_df, coords = c("lon", "lat"), crs = 4326)
      
      # Store original coordinates as data.table for fast binding
      cent_coords_dt <- data.table( lat = centroid_df$lat, lon = centroid_df$lon, centroid.id = centroid_df$centroid.id )
      #----
      
      
      # Initialize storage for compiled data    ----
      compiled_var_list <- list()
      crs_summary <- data.frame(variable = character(), crs = character(), 
                                n_files = integer(), stringsAsFactors = FALSE)
      #----
      
      
      
      
      # Loop through each climate variable directory
      for(input_dir in var_directories) {
            
         
            # Extract variable name from directory path
            var_name <- basename(input_dir)
            if(var_name %in% names(compiled_var_list)) {
                warning(paste0("Variable '", var_name, "' already processed; skipping duplicate directory."))
                next
            }
            message(paste0("\n=== Processing variable: ", var_name, " ==="))
            
            
            # Detect file type and select appropriate files    ----
            processed_dir <- file.path(input_dir, "processed")
            rescaled_dir <- file.path(input_dir, "rescaled")
            
            # Detect file type and select appropriate files
            processed_files <- list.files(processed_dir, pattern = "\\.nc$", full.names = FALSE)
            
            # Force use of rescaled files if they exist (for ANUCLIM)
            rescaled_files <- list.files(rescaled_dir, pattern = "\\.nc$", full.names = FALSE)
            if(length(rescaled_files) > 0) {
                message("  Using rescaled files")
                files_to_process <- rescaled_files
                file_dir <- rescaled_dir
            } else {
                message("  Using Original Resolution files")      
                files_to_process <- processed_files
                file_dir <- processed_dir
            }
            
            
            if(length(files_to_process) == 0) {
                  warning(paste0("No valid files found in ", input_dir))
                  next
            }
            
            message(paste0("  Found ", length(files_to_process), " files to process"))
            #----
            
         
            
            # Initialize list to store yearly data for this variable
            yearly_data_list <- list()
            var_crs_list <- c()
            
            
            # Loop through each file (year) for this variable and process the raster stack:    ----
            for(file_name in files_to_process) {
               
               # Extract year from raster file
               year <- str_extract(file_name, "\\d{4}")
               
               if(is.na(year)) {
                  warning(paste0("Could not extract year from filename: ", file_name))
                  next
               }
               
               message(paste0("  Extracting year ", year))
               
               tryCatch({
                  
                  # Read the raster stack
                  raster_data <- terra::rast(file.path(file_dir, file_name))
                  
                  # Store CRS
                  var_crs_list <- c(var_crs_list, as.character(crs(raster_data, proj = TRUE)))
                  
                  # Transform centroids to raster CRS
                  centroids_sf_proj <- st_transform(centroids_sf, crs = crs(raster_data, proj = TRUE))
                  
                  # Extract values (terra::extract returns a data.frame: first column = ID, rest = layers)
                  extracted_values <- terra::extract(raster_data, vect(centroids_sf_proj))
                  
                  # Remove the ID column
                  values_mat <- as.matrix(extracted_values[,-1])
                  
                  # Check if raster has multiple layers
                  n_layers <- ncol(values_mat)
                  n_centroids <- nrow(values_mat)
                  
                  # Expand centroids for each layer
                  cent_expanded <- cent_coords_dt[rep(1:.N, times = n_layers)]
                  
                  # Flatten values
                  values_vec <- as.vector(values_mat)
                  
                  # Determine dates for layers
                  if (!is.null(terra::time(raster_data))) {
                    raster_dates <- as.IDate(terra::time(raster_data))
                  } else {
                    year <- str_extract(file_name, "\\d{4}")
                    raster_dates <- seq(as.IDate(paste0(year, "-01-01")), by = 1, length.out = n_layers)
                  }
                  
                  dates_expanded <- rep(raster_dates, each = n_centroids)
                  
                  # Build the final data.table
                  extracted_dt <- copy(cent_expanded)
                  extracted_dt[, (var_name) := values_vec]
                  extracted_dt[, clim_date := dates_expanded]
                  
                  # Add to yearly list
                  yearly_data_list[[year]] <- extracted_dt
                  
                  # Clean up
                  rm(raster_data, extracted_values)
                  gc()
                  
               }, error = function(e) {
                  warning(paste0("Error processing ", file_name, ": ", e$message))
               })
            }
            #----
            
            
            
            
            # CRS checking for this variable    ----
            if(check_crs & length(var_crs_list) > 0) {
               unique_crs <- unique(var_crs_list)
               
               if(length(unique_crs) > 1) {
                  warning(paste0("Variable '", var_name, "' has files with different CRS:"))
                  for(crs_val in unique_crs) {
                     warning(paste0("  ", crs_val))
                  }
               }
               
               # Store CRS info for summary
               crs_summary <- rbind(crs_summary, 
                                    data.frame(variable = var_name,
                                               crs = unique_crs[1],
                                               n_files = length(files_to_process),
                                               stringsAsFactors = FALSE))
            }
            #----
            
            
            # Reshape data for this variable    ----
            if(length(yearly_data_list) == 0) {
               warning(paste0("No data extracted for variable: ", var_name))
               next
            }
            
            
            # Combine all yearly data.tables for this variable
            all_years_dt <- rbindlist(yearly_data_list, use.names = TRUE, fill = TRUE)
            
            # Already in long format: one column per variable + lat/lon/centroid.id/clim_date
            compiled_var_list[[var_name]] <- all_years_dt
            
            message(paste0("  Variable ", var_name, " complete: ", nrow(all_years_dt), " records"))
            
            # Clean up
            rm(yearly_data_list, all_years_dt)
            gc()


            #---- 
            
       }   #  end variable loop        
      
      
      
      
      
      # Checking that data was successfully extracted from the rasters    ----
      if(length(compiled_var_list) == 0) {
         stop("No climate data was successfully extracted from any variable")
      }
      
      message(paste0("Combining ", length(compiled_var_list), " variables: ", paste(names(compiled_var_list), collapse = ", ")))
      #----
      
      
      
      # Ensuring that all variables have the consistent keys for the "full_join" to avoid duplication    ----
      key_counts <- lapply(compiled_var_list, function(df) {
        df %>%
          distinct(lat, lon, centroid.id, clim_date) %>%
          nrow()
      })
      
      diag_df <- data.frame(
        variable = names(compiled_var_list),
        n_keys = unlist(key_counts)
      )
      
      print(diag_df)
      
      if(length(unique(diag_df$n_keys)) != 1) {
        stop(" Not all variables have the same number of unique join keys. This may cause row duplication.")
      }
      #----
      
      
      
            
      # Merge all variables using data.table ----
      
      # Ensure all elements are data.tables
      compiled_var_list <- lapply(compiled_var_list, as.data.table)
      
      # New key columns for single-layer raster
      key_cols <- c("lat", "lon", "centroid.id", "clim_date")
      
      # Set keys for fast joining
      lapply(compiled_var_list, setkeyv, key_cols)
      
      # Merge all variables iteratively
      all_clim_dt <- Reduce(function(x, y) merge(x, y, by = key_cols, all = TRUE),
                            compiled_var_list)
      

      
      message(paste0("Total records after merging: ", nrow(all_clim_dt)))
      #----
            
      
      
      
      # Format date columns    ----
      
      # Convert date column to proper Date object
      all_clim_dt[, clim_date := as.IDate(clim_date)]
      all_clim_dt[, clim_year := year(clim_date)]       
      all_clim_dt[, clim_month := month(clim_date)]
      all_clim_dt[, clim_m.day := mday(clim_date)]
      all_clim_dt[, clim_day.month := paste0(clim_m.day, ".", clim_month)]
      all_clim_dt[, id := paste0(centroid.id, "_", year(clim_date))]
      
      # Reorder columns
      setcolorder(all_clim_dt, c("lat", "lon", "centroid.id", "id", "clim_date", "clim_year",
                                 "clim_month", "clim_m.day", "clim_day.month",
                                 setdiff(names(all_clim_dt), c("lat","lon","centroid.id","id",
                                                               "clim_date","clim_year",
                                                               "clim_month","clim_m.day","clim_day.month"))))
      #----
      
      
      
      
      
      # Save final compiled dataframe and output to user    ----
      saveRDS(all_clim_dt, file = output_filepath)
      message(paste0("Compiled climate data saved to: ", output_filepath))

      return(all_clim_dt)
      #-----
}

```


```{r testing the function}


clim_dir <- c("D:/Mateo/OneDrive - Macquarie University/2 - Tisiphone Abeona Project/Analysis/github/clim_data/daily_rain",
              "D:/Mateo/OneDrive - Macquarie University/2 - Tisiphone Abeona Project/Analysis/github/clim_data/radiation", 
              "D:/Mateo/OneDrive - Macquarie University/2 - Tisiphone Abeona Project/Analysis/github/clim_data/tmin",
              "D:/Mateo/OneDrive - Macquarie University/2 - Tisiphone Abeona Project/Analysis/github/clim_data/tmax",
              "D:/Mateo/OneDrive - Macquarie University/2 - Tisiphone Abeona Project/Analysis/github/clim_data/t_min",
              "D:/Mateo/OneDrive - Macquarie University/2 - Tisiphone Abeona Project/Analysis/github/clim_data/t_max")


centroids <- read.csv("test_dataset/region.grid_centroids_res=0.05.csv")
str(centroids)

test_conversion <- extract_and_compile_clim.data(clim_dir, centroids, "test_dataset/compiled_raster_clim_df.RDS")
str(test_conversion)

```
#. 






# assign_clim.data


This function assigns climate data to individual samples based on their location and dates, supplied through a metadata file containing rounded latitude and longitude coordinates, sample ID and date of sampling.

The period for which climate data is then assigned to the individual is define by the user, allowing the collection of climate data before and after sampling, measured in periods of years, months and days. 

In order to facilitate date collection, the user can define whether or not the date fences (at the ends of the defined time period) are included in the collection period.

Saves files to RDS

```{r function for assigning climate data to samples}

# this function will extract for each sample the climate data associated with it for the period defined by the user


# Function INPUT DATA     ----

#    -    grid_df                   -  The gridded Climate Dataframe produced by the "compile_raster_dfs" function.


#...............................................................................................................................................................................


#    -    sample_df                 -  a dataframe of samples for which the climate data is to be collected. 
#                                         -  Each row should be a unique sample and sample ID  
#                                         -  Must contain the following collumns, named as described:
#                                                -  sample.id    - Sample ID for each sample
#                                                -  lat          - latitude for each sample (rounded to match the target resolution)
#                                                -  lon          - longitude for each sample (rounded to match the target resolution)
#                                                -  date         - date of collection of sample (a character string as "dd/mm/yyyy" - i.e. the 24th of December, 1965 as "24/12/1965")
#                                         -  Example sample_df:
                                                      # 'data.frame':	428 obs. of  14 variables:
                                                      #  $ sample.id     : chr  "ANIC-14" "ANIC-16" "ANIC-17" "ANIC-18" ...
                                                      #  $ sample_no     : int  14 16 17 18 20 21 22 23 24 25 ...
                                                      #  $ subspp        : chr  "Abeona" "Abeona" "Abeona" "Abeona" ...
                                                      #  $ sex           : int  1 1 1 1 1 1 1 1 1 1 ...
                                                      #  $ collection    : chr  "ANIC" "ANIC" "ANIC" "ANIC" ...
                                                      #  $ lat           : num  -35.6 -35.6 -35.1 -35.7 -35.7 ...
                                                      #  $ lon           : num  150 150 150 150 150 ...
                                                      #  $ elev          : int  28 2 605 16 0 869 605 2 30 28 ...
                                                      #  $ date          : chr  "22/3/2020" "25/10/2020" "29/11/2020" "22/1/2020" ...
                                                      #  $ sampling_year : int  2020 2020 2020 2020 2020 2020 2020 2020 2020 2020 ...
                                                      #  $ sampling_month: int  3 10 11 1 10 2 11 10 2 3 ...
                                                      #  $ sampling_day  : int  22 25 29 22 4 16 29 25 28 22 ...
                                                      #  $ sampling_yrday: int  81 299 333 22 277 47 333 299 59 81 ...
                                                      #  $ gen_cycle     : int  -1 1 1 1 1 -1 1 1 -1 -1 ...


#...............................................................................................................................................................................


#    -    pre_period                -  the length of time prior to the sample collection date for which to collate climate data
#                                         -  formatted as a List of Integers where:
#                                               - First Element  = Number of years
#                                               - Second Element = number of Months
#                                               - Third Element = Number of Days
                                                            #  Capturing from  1 Year prior to capture date                          list(1, 0, 0)
                                                            #  Capturing from 6 months prior to capture date                         list(0, 6, 0)
                                                            #  Capturing from 10 Days prior to capture date                          list(0, 0, 10)
                                                            #  Capturing from 2 years, 9 months and 4 days prior to capture date     list(2, 9, 4)


#...............................................................................................................................................................................


#    -    include_start_date        -  IF TRUE, then the collection includes the first fence date


#...............................................................................................................................................................................


#    -    post_period               -  the length of time following the sample collection date for which to collate climate data
#                                         -  formatted as a List of Integers where:
#                                               - First Element  = Number of years
#                                               - Second Element = number of Months
#                                               - Third Element = Number of Days
                                                            #  Capturing until  1 Year after to capture date                          list(1, 0, 0)
                                                            #  Capturing until 6 months after to capture date                         list(0, 6, 0)
                                                            #  Capturing until 10 Days after to capture date                          list(0, 0, 10)
                                                            #  Capturing until 2 years, 9 months and 4 days after to capture date     list(2, 9, 4)


#...............................................................................................................................................................................


#    -    include_end_date          -  IF TRUE, then the collection includes the final fence date


#...............................................................................................................................................................................


#    -    output_directory          -  The path (including file name and extension) to the location where the output will be saved (as .RDS)
#----




assign_clim.data <- function(grid_df, sample_df, pre_period, include_start_date, post_period, include_end_date, output_directory) {
      
      # Ensuring the required packages are loaded:
      library(tidyverse)
      library(data.table)
      

      # Ensuring that the gridded climate dataframe has all date objects formatted correctly    ----
      grid_df$clim_date <- as.Date(grid_df$clim_date)
      #----
      
      
      if (dir.exists(output_directory)) {
          stop("Output directory path is a folder, please provide a full file path including filename.rds")
      }

      
      # Defining the inclusion and exclusion of fence dates    ----
      if(include_start_date == TRUE) {
            pre.fence_buffer <- 0
      } else if(include_start_date == FALSE) {
            pre.fence_buffer <- 1
      } else {
            stop(paste0("Define Inclusion/Exclusion of Start Date"))
      }
      
      if(include_end_date == TRUE) {
            post.fence_buffer <- 0
      } else if(include_end_date == FALSE) {
            post.fence_buffer <- 1
      } else {
            stop(paste0("Define Inclusion/Exclusion of end Date"))
      }
      #----
      
      
      # Extracting the pre-collection date periods    ----
      pre.period <- years(pre_period[[1]]) + months(pre_period[[2]]) + days(pre_period[[3]]) - days(pre.fence_buffer)
      
      # Extracting the post-collection date periods    ----
      post.period <- years(post_period[[1]]) + months(post_period[[2]]) + days(post_period[[3]]) - days(post.fence_buffer)
      #----
     
      
      # processing date periods for the samples in order to filter the climate data from there
      # Converting the date object to a lubridate format
      # Calculating the start and end dates for each sample   ----
      meta <- sample_df %>%
                    dplyr::select(sample.id, lat, lon, date) %>%
                    mutate(date = dmy(date),
                           start_date = date - pre.period,
                           end_date = date + post.period) 
      #----
     
     
     
      # removing Unneccessary dates to reduce computational load    ----
      grid_df <- grid_df[grid_df$clim_date >= min(meta$start_date) & grid_df$clim_date <= max(meta$end_date),]
      #----
     
     
     
      # Converting the dataframe to a data.table:
      grid_dt <- as.data.table(grid_df)
      setkey(grid_dt, lat, lon, clim_date)
      
      
      # Applying a function for each row in the data:
      results_list <- lapply(1:nrow(meta), function(i) {
            
            # Extracting the indexing values for each individual:
            meta_sample.id <- meta$sample.id[i]
            sample.lat <- meta$lat[i]
            sample.lon <- meta$lon[i]
            sample.start_date <- meta$start_date[i]
            sample.end_date <- meta$end_date[i]
            
            
            # Filtering the data.table using the indexing keys set previously:
            ind.clim.dt <- grid_dt[lat == sample.lat
                                   & lon == sample.lon
                                   & clim_date >= sample.start_date
                                   & clim_date <= sample.end_date]
            
            # adding a sample.id value:
            ind.clim.dt[, sample.id := meta_sample.id]
            

            # # Printing Progress
            if (i %% 50 == 0 || i == nrow(meta)) {
                  message("Processed ", i, "/", nrow(meta))
                  }
            
            # Returning the result
            return(ind.clim.dt)
      })
      
      # Combining the resulting data.tables:
      all.inds_clim.df <- rbindlist(results_list)
      
      # Cleaning the environment
      rm(grid_df, grid_dt, results_list)
      gc()     

      
      # Converting back to a data.frame for compatibility:
      all.inds_clim.df <- all.inds_clim.df %>%
                                    as.data.frame() %>%
                                    dplyr::select(sample.id, lat, lon, centroid.id, clim_date, everything())
      #----

     
     
      # merging with the metadata again so that we can have the sampling collection date    ----
      ind_collection <- meta %>%
                              dplyr::select(sample.id, lat, lon, date)
     
      ind.clim_meta <- merge(ind_collection, all.inds_clim.df, by = c("sample.id", "lat", "lon"))
     
      rm(all.inds_clim.df)
      #----
     
     
      # Saving the output:
      saveRDS(ind.clim_meta, output_directory)
     
     
     
      # Reporting the Output ----
      n.check <- length(unique(ind.clim_meta$sample.id))
     
      message(paste0("Climate Data Assigned to ", n.check, " Individuals.", "\n",
                    
                    "Check the Number of Records Associated with Each Individual:", "\n",
                    
                    "All inds should have the same number of records associated (with the potential exception of leap years)."))
     
     
     records_per_sample <- as.data.frame(table(ind.clim_meta$sample.id))
     colnames(records_per_sample) <- c("sample.id", "n_records")
     print(table(records_per_sample$n_records))

     print(paste0("All inds should have the same number of records as there are days in the user defined interval."))
     #----     
     
     
     
     return(ind.clim_meta)
}

```


```{r testing the function}

# Test Run:
test_compile.raster <- readRDS("github/compiled_raster_clim_df.RDS")
str(test_compile.raster)

ind_meta <- read.csv("github/Example_metadata.csv")
str(ind_meta)


test_assign_clim.data <- assign_clim.data(test_compile.raster,
                                          ind_meta, c(1,0,0), include_start_date = FALSE,
                                          c(0,0,0), include_end_date = TRUE,
                                          "github/test_assign_ind.clim.RDS")



```
#. 





# compute_ind_bioclims

This function computes bioclimatic indices for each sample based on the indiviaul sample climate period supplied from the previous function.
NOTE: This function is designed to compute BIOclimatic indices for each sample on the assumption that each sample has 1 year of climate data (365 or 366 days)
            The output of this function will not be accurate to computed bioclimatic indices if this time period is not provided. 

Computes BIOCLIM 1-27 using daily values for maximum temperature, minimum temperature, precipitation and radiation, allowing the user to decide which BIOCLIM indices they would like to compute. 

In order to compute all indices, the function requires all 4 of the above described climate variables, however, the function will only fail if the user does not provide the specific climate variables required for the indices they have selected. 



```{r function for computing bioclimatic indices for each year from daily climate data - FOR INDIVIDUALS - BASED ON COLLECTION DATE}


# this function will Compute BIO climatic Indices 1-27 for each individual for their annual climate period, produced in the previous function. 



# Function INPUT DATA     ----


#    -    ind.clim_meta             -  The dataframe produced by the "assign_clim.data" function containing individuals, 
#                                         -  NOTE: This function requires that the interval of time associated with each individual be equal to 1 year or 365 days. 


#...............................................................................................................................................................................


#    -    bioclim_indices           -     A vector of numbers identifying which bioclimatic indices the user wants the function to compute:
#                                         Example:    c(1, 2, 3, 4, 5, 6, 7, 8, 15, 22, 21, 26)
#                                         -  Indices Range from 1 through to 27:
#                                                     1 - 11 = Temperature Based Indices
#                                                     12 - 19 = Precipitation Indices
#                                                     20 - 27 = Radiation Indices
#                                         -  NOTE: Different Indices Require Different Variables to be included:
                                                #    BIO1  -     Max Temp  |  Min Temp
                                                #    BIO2  -     Max Temp  |  Min Temp
                                                #    BIO3  -     Max Temp  |  Min Temp
                                                #    BIO4  -     Max Temp  |  Min Temp 
                                                #    BIO5  -     Max Temp
                                                #    BIO6  -     Min Temp
                                                #    BIO7  -     Max Temp  |  Min Temp
                                                #    BIO8  -     Max Temp  |  Min Temp | Precipitation
                                                #    BIO9  -     Max Temp  |  Min Temp | Precipitation
                                                #    BIO10  -    Max Temp
                                                #    BIO11  -    Min Temp
                                                #    BIO12  -    Precipitation
                                                #    BIO13  -    Precipitation
                                                #    BIO14  -    Precipitation
                                                #    BIO15  -    Precipitation
                                                #    BIO16  -    Precipitation
                                                #    BIO17  -    Precipitation
                                                #    BIO18  -    Precipitation  |  Max Temp
                                                #    BIO19  -    Precipitation  |  Min Temp
                                                #    BIO20  -    Radiation
                                                #    BIO21  -    Radiation
                                                #    BIO22  -    Radiation
                                                #    BIO23  -    Radiation
                                                #    BIO24  -    Radiation  |  Precipitation
                                                #    BIO25  -    Radiation  |  Precipitation
                                                #    BIO26  -    Radiation  |  Max Temp
                                                #    BIO27  -    Radiation  |  Min Temp


#...............................................................................................................................................................................


#    -    var.names                 -     A vector of the variables to be used to compute bioclimatic indices for each Individual:
#                                         -  Must Include one or more of the following:
#                                                     - Maximum Temperature         -     tmax (AWAP) or max_temp (SILO) or t_max (ANUCLIM)
#                                                     - Minimum Temperature         -     tmin (AWAP) or min_temp (SILO) or t_min (ANUCLIM)
#                                                     - Precipitation               -     precip (AWAP) or daily_rain (SILO) or rain (ANUCLIM)
#                                                     - Radiation                   -     radiation (SILO) or srad (ANUCLIM)
#                                         - The function will handle having multiple synonomous variables (see above) in the dataframe, using only those called in "var.names"
#                                               NOTE: If there are several version of the same climate variable, the function will force an error.
#                                                    BOM AWAP Variable    |    SILO Variable    |    ANUCLIM          
#                                       ..................................|.........................................
#                                                    precip               |    daily_rain       |    rain
#                                                    tmax                 |    max_temp         |    t_max
#                                                    tmin                 |    min_temp         |    t_min
#                                                                         |    radiation        |    srad


#...............................................................................................................................................................................


#    -    output_directory          -    a path (including file name and extension) to the location where the output will be saved (as .RDS)

#----


compute_ind_bioclims <- function(ind.clim_meta, bioclim_indices, var.names, output_directory) {
      
      # loading required packages
      library(tidyverse)
      
      
      # Creating a copy of the data to manipulate
      clim <- ind.clim_meta
      results_list <- list()

      
      # checking User input is valid   ----
      
      # Bioclim indices
      if(all(bioclim_indices %in% c(1:27)) == FALSE) {
            stop("Invalid Bioclimatic Indice Values. Values of Bioclimatic Indices should Range from 1 - 27.")
      }
      
      
      
      # Climate variables:
      valid_var.names <- c("tmax", "tmin", "precip", "max_temp", "min_temp", "daily_rain", "radiation")
      
      if(all(var.names %in% valid_var.names) == FALSE) {
            stop("Invalid Climate Variable Names Supplied. Check supplied variable names.")
      }
      #----
      
      
      # Checking that the user has only used one synomous variable name   ---- 
      
      # defining synonym groups;
      synonymous_vars <- list(precipitation = c("daily_rain", "precip", "rain"),
                              max_temperature = c("tmax", "t_max", "max_temp"),
                              min_temperature = c("tmin", "t_min", "min_temp"),
                              radiation = c("radiation", "srad"))
      
      for (group_name in names(synonymous_vars)) {
            
            synonyms <- synonymous_vars[[group_name]]
            user.synonyms <- intersect(var.names, synonyms)
            
            
            if(length(user.synonyms) > 1) {
                  
                  stop(paste0("Multiple Synonomous Variable Names for ", group_name, ": ", "\n",
                              paste(user.synonyms, collapse = ", "), "\n", 
                              "Specify 1 variable name for each climate variable category."))
                  
            }
      }
      #----
      
      
      
      
      # Clearing Potential Duplicate Climate values (BOM AWAP vs SILO vs ANUClim) ----
      
      # Define standardization rules: canonical name -> alternative names
      standardization_map <- list(
        precip = c("rain", "daily_rain"),
        tmax = c("max_temp", "t_max"),
        tmin = c("min_temp", "t_min"),
        rad = c("srad", "radiation")
      )
      
      # Identify variables actually present in the dataset
      present_vars <- names(clim)
      
      # Process each canonical variable
      for (canonical in names(standardization_map)) {
        
        alternatives <- standardization_map[[canonical]]
        
        # Find which version exists in var.names (if any)
        existing_in_varnames <- c(canonical, alternatives)[c(canonical, alternatives) %in% var.names]
        
        if (length(existing_in_varnames) > 0) {
          
          primary_var <- existing_in_varnames[1]  # The one specified in var.names
          
          # Remove all other alternatives that exist in the dataset
          vars_to_remove <- setdiff(c(canonical, alternatives), primary_var)
          vars_to_remove <- intersect(vars_to_remove, present_vars)
          
          if (length(vars_to_remove) > 0) {
            clim <- clim %>% 
              dplyr::select(-all_of(vars_to_remove))
            
            message(paste0("Removed duplicate variable(s) '", 
                           paste(vars_to_remove, collapse = "', '"), 
                           "' because '", primary_var, "' is specified in var.names"))
          }
          
          # Rename to canonical form if needed
          if (primary_var != canonical && primary_var %in% names(clim)) {
            clim <- clim %>%
              dplyr::rename(!!canonical := !!primary_var)
            
            var.names[var.names == primary_var] <- canonical
            
            message(paste0("Standardized '", primary_var, "' to '", canonical, "'"))
          }
        }
      }
      #----

      
      
      # Checking That the variables required to calculate requested indices are present    ----
      
      # Defining which indices require which variables:
      indices_depend_max.temp <- c(1, 2, 3, 4, 5, 7, 8, 9, 10, 18, 26)
      indices_depend_min.temp <- c(1, 2, 3, 4, 6, 7, 8, 9, 11, 19, 27)
      indices_depend_precip <- c(8, 9, 12, 13, 14, 15, 16, 17, 18, 19, 24, 25)
      indices_depend_rad <- c(20, 21, 22, 23, 24, 25, 26, 27)
      
      
      
      # Check that each indice to be computed has the required variables present:
      for(i in bioclim_indices) {
            
            if(i %in% indices_depend_max.temp & !("tmax" %in% var.names)) {
                  stop("Maximum Temperature Variables (tmax, max_temp or t_max) Required to Compute BIO", i, " Required - Revise Input Variables.")
            }
            
            if(i %in% indices_depend_min.temp & !("tmin" %in% var.names)) {
                  stop("Minimum Temperature Variables (tmin, min_temp or t_min) Required to Compute BIO", i, " Required - Revise Input Variables.")
            }
            
            if(i %in% indices_depend_precip & !("precip" %in% var.names)) {
                  stop("Precipitation Variables (precip, daily_rain or rain) Required to Compute BIO", i, " Required - Revise Input Variables.")
            }
            
            if(i %in% indices_depend_rad & !("rad" %in% var.names)) {
                  stop("Radiation Variables (radiation, srad) Required to Compute BIO", i, " Required - Revise Input Variables.")
            }
      }
      #----
      
      
      
      
      # Formatting all Required Date and Time data for the climate data    ----
      clim$sample_date <- date(clim$date)
      clim$clim_date <- date(clim$clim_date)
      clim$clim_year <- year(clim$clim_date)
      clim$clim_month <- month(clim$clim_date)
      clim$clim_m.day <- day(clim$clim_date)
      #----
      
      
      
      
      ############################################    Monthly Aggregations    ##############################################
      
      # Temperature Monthly Aggregations      ----
      if("tmax" %in% var.names & "tmin" %in% var.names) {
            
            # Computing Daily Mean Temperature
            clim$daily_av_temp <- (clim$tmin + clim$tmax)/2
            clim$diurnal_range <- clim$tmax - clim$tmin
            clim$daily_av_temp_k <- clim$daily_av_temp + 273.15
            
            
            # Monthly Aggregations
            monthly_av_temp <- aggregate(daily_av_temp ~ sample.id + clim_month, data = clim, FUN = mean)%>%
                                                                              dplyr::rename(month_av_temp = daily_av_temp)
            
            monthly_max_temp <- aggregate(tmax ~ sample.id + clim_month, data = clim, FUN = mean)%>%
                                                                              dplyr::rename(month_max_temp = tmax)
            
            monthly_min_temp <- aggregate(tmin ~ sample.id + clim_month, data = clim, FUN = mean)%>%
                                                                              dplyr::rename(month_min_temp = tmin)
            
            monthly_av_temp_k <- aggregate(daily_av_temp_k ~ sample.id + clim_month, data = clim, FUN = mean)%>%
                                                                              dplyr::rename(month_av_temp_k = daily_av_temp_k)
            
            # Merging back into Clim:
            clim <- clim %>%
                        left_join(monthly_av_temp, by = c("sample.id", "clim_month")) %>%
                        left_join(monthly_max_temp, by = c("sample.id", "clim_month")) %>%
                        left_join(monthly_min_temp, by = c("sample.id", "clim_month")) %>%
                        left_join(monthly_av_temp_k, by = c("sample.id", "clim_month"))
      
            
      } else if ("tmax" %in% var.names) {

            # Computing Monthly Aggregation
            monthly_max_temp <- aggregate(tmax ~ sample.id + clim_month, data = clim, FUN = mean)%>%
                                                                              dplyr::rename(month_max_temp = tmax)
            
            # Merging back into Clim:
            clim <- clim %>%
                        left_join(monthly_max_temp, by = c("sample.id", "clim_month"))
            
      } else if ("tmin" %in% var.names) {

            # Computing Monthly Aggregation
            monthly_min_temp <- aggregate(tmin ~ sample.id + clim_month, data = clim, FUN = mean)%>%
                                                                              dplyr::rename(month_min_temp = tmin)
            
            # Merging back into Clim:
            clim <- clim %>%
                        left_join(monthly_min_temp, by = c("sample.id", "clim_month"))            
            
      }
      #----
      
      
      # Precipitation Monthly Aggregations      ----
      if("precip" %in% var.names) {
            
            # Monthly Aggregations:
            monthly_av_rain <- aggregate(precip ~ sample.id + clim_month, data = clim, FUN = mean)%>%
                                                                              dplyr::rename(month_av_rain = precip)
            
            monthly_tot_rain <- aggregate(precip ~ sample.id + clim_month, data = clim, FUN = sum)%>%
                                                                              dplyr::rename(month_tot_rain = precip)
            
            # merging back into clim:
            clim <- clim %>% 
                        left_join(monthly_av_rain, by = c("sample.id", "clim_month")) %>%
                        left_join(monthly_tot_rain, by = c("sample.id", "clim_month"))
      }
      #----
      
      
      # Radiation Monthly Aggregations      ----
      if("rad" %in% var.names) {
            
            # Monthly Aggregations:
            monthly_av_rad <- aggregate(rad ~ sample.id + clim_month, data = clim, FUN = mean)%>%
                                                                              dplyr::rename(month_av_rad = rad)
            
            
            # merging back into clim:
            clim <- clim %>% 
                        left_join(monthly_av_rad, by = c("sample.id", "clim_month"))
      }
      #----
      
      
      
      ############################################    Quarterly Aggregations    ##############################################
      
      # Quarter Definitions     ----
      quart_combos <- list(c(1, 2, 3),  c(2, 3, 4), 
                           c(3, 4, 5),  c(4, 5, 6), 
                           c(5, 6, 7),  c(6, 7, 8), 
                           c(7, 8, 9),  c(8, 9, 10), 
                           c(9, 10, 11),  c(10, 11, 12),
                           c(11, 12, 1),   c(12, 1, 2))
      #----
      
      
      # Running through each quarter combination and computing values for that quarter    ----
      
      # Initialising an Empty List:
      q_results_list <- list()
      
      for (months in quart_combos) {
            
            
            # Restricting the dataframe to only those months found in this quarter:
            q_filtered.df <- clim %>%
                              dplyr::filter(clim_month %in% months)
            
            
            # Initialising an Empty List
            q_list <- list()
            
            
            # Temperature-based aggregations
            if("tmax" %in% var.names) {
                  q_list[[ "q_max_temp" ]] <- aggregate(tmax ~ sample.id, data = q_filtered.df, FUN = mean) %>%
                                                                  dplyr::rename(q_max_temp = tmax)
            }
            
            if("tmin" %in% var.names) {
                  q_list[[ "q_min_temp" ]] <- aggregate(tmin ~ sample.id, data = q_filtered.df, FUN = mean) %>%
                                                                  dplyr::rename(q_min_temp = tmin)
            }
              
            if(all(c("tmax","tmin") %in% var.names)) {
                  q_list[[ "q_av_temp" ]] <- aggregate(daily_av_temp ~ sample.id, data = q_filtered.df, FUN = mean) %>%
                                                                  dplyr::rename(q_av_temp = daily_av_temp)
            }
            

            
            # Precipitation-based aggregations ----
            if("precip" %in% var.names) {
                  q_list[[ "q_tot_rain" ]] <- aggregate(precip ~ sample.id, data = q_filtered.df, FUN = sum) %>%
                                                                  dplyr::rename(q_tot_rain = precip)
            }
            
            
            
            # Radiation-based aggregations ----
            if("rad" %in% var.names) {
                  q_list[[ "q_av_rad" ]] <- aggregate(rad ~ sample.id, data = q_filtered.df, FUN = mean) %>%
                                                                  dplyr::rename(q_av_rad = rad)
            }
            
           
            # Combine into a single DF for this quarter
            if(length(q_list) > 0) {
                  q_df <- q_list %>% purrr::reduce(full_join, by = "sample.id")
                  q_results_list[[ paste(months, collapse = "-") ]] <- q_df
            }
      }  
         
      
      # Bind All the Quarter Results:
      quarter_stats <- dplyr::bind_rows(q_results_list, .id = "quarter")
      quarter_stats$quarter <- as.factor(quarter_stats$quarter)
      
      # Rename columns
      names(quarter_stats) <- make.names(names(quarter_stats), unique = TRUE)
      #----
      
      
      ############################################    TEMPERATURE  -  Indice Calculations    ##############################################
      
      # Annual Mean Temperature - BIO1      ----
      #   -  Equal to the annual mean of the daily average temperature, calculated as the average between maximum and minimum temperature. 
      if (1 %in% bioclim_indices) {
            results_list[["1"]] <- aggregate(daily_av_temp ~ sample.id, data = clim, FUN = mean) %>%
                                                                              dplyr::rename(bio1 = daily_av_temp)
      }
      #----
      
      
      
      # Mean Annual Diurnal Range  -  BIO2      ----
      #   -  Equal to the annual average of the difference between daily maximum and minimum temperatures. 
      if (any(c(2, 3) %in% bioclim_indices)) {      # BIO3 Depends on BIO2 to be computed - therefore, we include this in the conditional

            results_list[["2"]] <- aggregate(diurnal_range ~ sample.id, data = clim, FUN = mean) %>%
                                                                              dplyr::rename(bio2 = diurnal_range)
      }
      #----
      
      
      
            ####    BIO3 computer AFTER BIO7 to avoid unnecssary Code
      
      
      
      
      # Temperature Seasonality (Standard Deviation)  -  BIO4      ----
      #   -  Equal to the SD of the monthly average of daily average temperatures (calculated as the mean of the maximum and minimum temperatures).
      if (4 %in% bioclim_indices) {
            
            # computing the standard deviation in monthly average temp in Kelvin
            month_av_temp_K_sd <- aggregate(month_av_temp_k ~ sample.id, data = clim, FUN = sd) %>%
                                    dplyr::rename(month_av_K_sd = month_av_temp_k)
            
            # computing the yearly average of monthly average temp in Kelvin
            yearly_av_tempk <- aggregate(month_av_temp_k ~ sample.id, data = clim, FUN = mean) %>%
                                    dplyr::rename(year_av_temp_k = month_av_temp_k)
            
            # merging dataframes together
            av_tempk_cv <- merge(month_av_temp_K_sd, yearly_av_tempk, by = "sample.id")
            
            # computing BIO4 - 
            av_tempk_cv$bio4 <- (av_tempk_cv$month_av_K_sd/av_tempk_cv$year_av_temp_k)*100
            
            # saving Result
            results_list[["4"]] <- av_tempk_cv %>%
                                          dplyr::select(sample.id, bio4)
            
            # removing all objects:
            rm(month_av_temp_K_sd, yearly_av_tempk, av_tempk_cv)
      }
      #----
      
      
        
      
      # Mean Maximum Temperature of Warmest Month - BIO5      ----
      #   -  Equal to the monthly average maximum daily temperature for the month with the highest monthly average daily maximum temperature. 
      if (any(c(5, 7, 3) %in% bioclim_indices)) {      # BIO7 and BIO3 Depend on BIO5 to be computed - therefore, we include this in the conditional
            
            results_list[["5"]] <- aggregate(month_max_temp ~ sample.id, data = clim, FUN = max) %>%
                                                                        dplyr::rename(bio5 = month_max_temp)
      }
      #----
      
      

      
      # Mean Minimum Temperature of Coldest Month - BIO6      ----
      #   -  Equal to the monthly average minimum daily temperature for the month with the lowest monthly average daily minimum temperature. 
      if (any(c(6, 7, 3) %in% bioclim_indices)) {      # BIO7 and BIO3 Depend on BIO6 to be computed - therefore, we include this in the conditional
            
            results_list[["6"]] <- aggregate(month_min_temp ~ sample.id, data = clim, FUN = min) %>%
                                                                        dplyr::rename(bio6 = month_min_temp)
      }
      #----
        
      
      
      # Annual Temperature Range - BIO7      ----
      #   -  Equal to the difference between the average monthly maximum daily temperature for the warmest month 
      #                                                     and the average monthly minimum daily temperature for the coldest month (BIO5 - BIO6)
      if (any(c(7, 3) %in% bioclim_indices)) {      # BIO3 Depends on BIO7 to be computed - therefore, we include this in the conditional
            
            # merging Bio5 and BIO6
            pre_bio7 <- merge(results_list[["5"]], results_list[["6"]], by = "sample.id")
            
            # Computing bio7
            pre_bio7$bio7 <- pre_bio7$bio5 - pre_bio7$bio6
            
            # Saving the result
            results_list[["7"]] <- pre_bio7 %>%
                                          dplyr::select(sample.id, bio7)
            
            # cleaning up environment
            rm(pre_bio7)
      }
      #----
      
      
      
      # Isothermality (The Daily Temperature Range Relative to Annual Temperature Range)  -  BIO3      ----
      #   -  Equal to the ratio of the mean annual diurnal range to the Annual temperature range (BIO2 / BIO7)
      if (3 %in% bioclim_indices) {
            
            # merging Bio5 and BIO6
            pre_bio3 <- merge(results_list[["2"]], results_list[["7"]], by = "sample.id")
            
            # Computing bio7
            pre_bio3$bio3 <- (pre_bio3$bio2 / pre_bio3$bio7)*100
            
            # Saving the result
            results_list[["3"]] <- pre_bio3 %>%
                                          dplyr::select(sample.id, bio3)
            
            # cleaning up environment
            rm(pre_bio3)
      }
      #----
       
      
      
      # Mean Average Daily Temperature of Wettest Quarter - BIO8      ----
      #   -  Equal to the quarterly mean of daily average temperature for the quarter of the year where precipitation was highest. 
      if (8 %in% bioclim_indices) {
            
            pre_bio8 <- quarter_stats %>%
                              dplyr::group_by(sample.id) %>%
                              dplyr::filter(q_tot_rain == max(q_tot_rain)) %>%
                              dplyr::summarise(q_av_temp = mean(q_av_temp), .groups = "drop")
            
            results_list[["8"]] <- pre_bio8 %>%
                                          dplyr::rename(bio8 = q_av_temp)
            
            rm(pre_bio8)
      }
      #----
        
      
      
      
      # Mean Average Daily Temperature of driest Quarter - BIO9      ----
      #   -  Equal to the quarterly mean of daily average temperature for the quarter of the year where precipitation was lowest. 
      if (9 %in% bioclim_indices) {
            
            pre_bio9 <- quarter_stats %>%
                              dplyr::group_by(sample.id) %>%
                              dplyr::filter(q_tot_rain == min(q_tot_rain)) %>%
                              dplyr::summarise(q_av_temp = mean(q_av_temp), .groups = "drop")
            
            results_list[["9"]] <- pre_bio9 %>%
                                          dplyr::rename(bio9 = q_av_temp)
            
            rm(pre_bio9)
      }
      #----
        
      
      
      
      # Mean Average Daily Temperature of Warmest Quarter - BIO10      ----
      #   -  Equal to the highest quarterly mean of daily average temperature. 
      if (10 %in% bioclim_indices) {
            
            pre_bio10 <- quarter_stats %>%
                              dplyr::group_by(sample.id) %>%
                              dplyr::filter(q_av_temp == max(q_av_temp)) %>%
                              dplyr::summarise(q_av_temp = mean(q_av_temp), .groups = "drop")
            
            results_list[["10"]] <- pre_bio10 %>%
                                          dplyr::rename(bio10 = q_av_temp)
            
            rm(pre_bio10)
      }
      #----
       
      
      
      
      # Mean Average Daily Temperature of Coldest Quarter - BIO11      ----
      #   -  Equal to the lowest quarterly mean of daily average temperature. 
      if (11 %in% bioclim_indices) {
            
            pre_bio11 <- quarter_stats %>%
                              dplyr::group_by(sample.id) %>%
                              dplyr::filter(q_av_temp == min(q_av_temp)) %>%
                              dplyr::summarise(q_av_temp = mean(q_av_temp), .groups = "drop")
            
            results_list[["11"]] <- pre_bio11 %>%
                                          dplyr::rename(bio11 = q_av_temp)
            
            rm(pre_bio11)
      }
      #----
      
      
      
      
      
      ############################################    PRECIPITATION  -  Indice Calculations    ##############################################
      
      # Total Annual Precipitation  -  BIO12      ----
      #   -  Equal to the annual sum of all daily precipitation. 
      if (12 %in% bioclim_indices) {
            
            results_list[["12"]] <- aggregate(precip ~ sample.id, data = clim, FUN = sum) %>%
                                                                              dplyr::rename(bio12 = precip)
      }
      #----
      
      
      
      # Total Precipitation During Wettest Month  -  BIO13      ----
      #   -  Equal to the monthly sum of all daily precipitation during the month with the highest precipitation
      if (13 %in% bioclim_indices) {
            
            results_list[["13"]] <- aggregate(month_tot_rain ~ sample.id, data = clim, FUN = max) %>%
                                                                              dplyr::rename(bio13 = month_tot_rain)
      }
      #----
      
      
      
      # Total Precipitation During Driest Month  -  BIO14      ----
      #   -  Equal to the monthly sum of all daily precipitation during the month with the lowest precipitation
      if (14 %in% bioclim_indices) {
            
            results_list[["14"]] <- aggregate(month_tot_rain ~ sample.id, data = clim, FUN = min) %>%
                                                                              dplyr::rename(bio14 = month_tot_rain)
      }
      #----
      
      
        
      # Seasonality Index for Rainfall  -  BIO15      ----
      #   -  Equal to the Standard Deviation of Monthly totals of precipitation for the year, divided by the average monthly precipitation
      #                                         for the year (added to 1 to avoid strange negative index values), multiplied by 100 to be expressed as a percentage.
      if (15 %in% bioclim_indices) {
            
            # computing the standard deviation in monthly total rainfall
            monthly_tot_rain_sd <- aggregate(month_tot_rain ~ sample.id, data = clim, FUN = sd) %>%
                                                      dplyr::rename(month_tot_rain_sd = month_tot_rain)
            
            # computing the yearly average of monthly average temp in Kelvin
            yearly_av_month_rain <- aggregate(month_tot_rain ~ sample.id, data = clim, FUN = mean) %>%
                                                      dplyr::rename(year_av_month_rain = month_tot_rain)
            
            # merging dataframes together
            tot_rain_cv <- merge(monthly_tot_rain_sd, yearly_av_month_rain, by = "sample.id")
            
            # computing BIO4 - 
            tot_rain_cv$bio15 <- (tot_rain_cv$month_tot_rain_sd/tot_rain_cv$year_av_month_rain)*100
            
            # saving Result
            results_list[["15"]] <- tot_rain_cv %>%
                                          dplyr::select(sample.id, bio15)
            
            # removing all objects:
            rm(monthly_tot_rain_sd, yearly_av_month_rain, tot_rain_cv)
      }
      #----
        
      
      
      # Precipitation for Wettest Quarter - BIO16      ----
      #   -  Equal to the total precipitation for the quarter (3 consecutive month period) with the highest total precipitation
      if (16 %in% bioclim_indices) {
            
            pre_bio16 <- quarter_stats %>%
                              dplyr::group_by(sample.id) %>%
                              dplyr::filter(q_tot_rain == max(q_tot_rain)) %>%
                              dplyr::summarise(q_tot_rain = mean(q_tot_rain), .groups = "drop")
            
            results_list[["16"]] <- pre_bio16 %>%
                                          dplyr::rename(bio16 = q_tot_rain)
            
            rm(pre_bio16)
      }
      #----
      
      
      
      # Precipitation for the Driest Quarter - BIO17      ----
      #   -  Equal to the total precipitation for the quarter (3 consecutive month period) with the lowest total precipitation
      if (17 %in% bioclim_indices) {
            
            pre_bio17 <- quarter_stats %>%
                              dplyr::group_by(sample.id) %>%
                              dplyr::filter(q_tot_rain == min(q_tot_rain)) %>%
                              dplyr::summarise(q_tot_rain = mean(q_tot_rain), .groups = "drop")
            
            results_list[["17"]] <- pre_bio17 %>%
                                          dplyr::rename(bio17 = q_tot_rain)
            
            rm(pre_bio17)
      }
      #----
      
      
      
      # Precipitation of Warmest Quarter  -  BIO18      ----
      #   -  Equal to the sum of precipitation for the warmest 3 months of the year. 
      if (18 %in% bioclim_indices) {
            
            pre_bio18 <- quarter_stats %>%
                              dplyr::group_by(sample.id) %>%
                              dplyr::filter(q_av_temp == max(q_av_temp)) %>%
                              dplyr::summarise(q_tot_rain = mean(q_tot_rain), .groups = "drop")
            
            results_list[["18"]] <- pre_bio18 %>%
                                          dplyr::rename(bio18 = q_tot_rain)
            
            rm(pre_bio18)
      }
      #----
        
      
      
      # Precipitation of Warmest Quarter  -  BIO19      ----
      #   -  Equal to the sum of precipitation for the coldest 3 months of the year. 
      if (19 %in% bioclim_indices) {
            
            pre_bio19 <- quarter_stats %>%
                              dplyr::group_by(sample.id) %>%
                              dplyr::filter(q_av_temp == min(q_av_temp)) %>%
                              dplyr::summarise(q_tot_rain = mean(q_tot_rain), .groups = "drop")
            
            results_list[["19"]] <- pre_bio19 %>%
                                          dplyr::rename(bio19 = q_tot_rain)
            
            rm(pre_bio19)
      }
      #----
      
      
      
      
      
      ############################################    RADIATION  -  Indice Calculations    ##############################################
      
      # Mean Annual Daily Radiation  -  BIO20      ----
      #   -  Equal to the annual average of daily radiation values. 
      if (20 %in% bioclim_indices) {
            
            results_list[["20"]] <- aggregate(rad ~ sample.id, data = clim, FUN = mean) %>%
                                                                              dplyr::rename(bio20 = rad)
      }
      #----
        
      
      
      # Mean Monthly Daily Radiation for the Month with the Highest Mean Radiation  -  BIO21      ----
      #   -  Equal to the highest monthly average of daily radiation for the year. 
      if (21 %in% bioclim_indices) {
            
            results_list[["21"]] <- aggregate(month_av_rad ~ sample.id, data = clim, FUN = max) %>%
                                                                              dplyr::rename(bio21 = month_av_rad)
      }
      #----
         
      
      
      # Mean Monthly Daily Radiation for the Month with the lowest Mean Radiation  -  BIO22      ----
      #   -  Equal to the lowest monthly average of daily radiation for the year. 
      if (22 %in% bioclim_indices) {
            
            results_list[["22"]] <- aggregate(month_av_rad ~ sample.id, data = clim, FUN = min) %>%
                                                                              dplyr::rename(bio22 = month_av_rad)
      }
      #----
        
      
      
      # Radiation seasonality  -  BIO23      ----
      #   -  Equal to the coefficient of variance for the monthly means daily radiation for the year. 
      if (23 %in% bioclim_indices) {
            
            # computing the standard deviation in monthly total rainfall
            monthly_av_rad_sd <- aggregate(month_av_rad ~ sample.id, data = clim, FUN = sd) %>%
                                                            dplyr::rename(month_av_rad_sd = month_av_rad)
            
            # computing the yearly average of monthly average temp in Kelvin
            yearly_av_month_rad <- aggregate(month_av_rad ~ sample.id, data = clim, FUN = mean) %>%
                                                      dplyr::rename(year_av_month_rad = month_av_rad)
            
            # merging dataframes together
            av_rad_cv <- merge(monthly_av_rad_sd, yearly_av_month_rad, by = "sample.id")
            
            # computing BIO4 - 
            av_rad_cv$bio23 <- (av_rad_cv$month_av_rad_sd/av_rad_cv$year_av_month_rad)*100
            
            # saving Result
            results_list[["23"]] <- av_rad_cv %>%
                                          dplyr::select(sample.id, bio23)
            
            # removing all objects:
            rm(monthly_av_rad_sd, yearly_av_month_rad, av_rad_cv)
      }
      #----
        
      
      
      # Mean Quarterly Radiation for the Wettest Quarter  -  BIO24      ----
      #   -  Equal to the quarterly mean of daily radiation for the quarter with the highest quarterly total rainfall. 
      if (24 %in% bioclim_indices) {
            
            pre_bio24 <- quarter_stats %>%
                              dplyr::group_by(sample.id) %>%
                              dplyr::filter(q_tot_rain == max(q_tot_rain)) %>%
                              dplyr::summarise(q_av_rad = mean(q_av_rad), .groups = "drop")
            
            results_list[["24"]] <- pre_bio24 %>%
                                          dplyr::rename(bio24 = q_av_rad)
            
            rm(pre_bio24)
      }
      #----
        
      
      
      # Mean Quarterly Radiation for the Driest Quarter  -  BIO25      ----
      #   -  Equal to the quarterly mean of daily radiation for the quarter with the lowest quarterly total rainfall. 
      if (25 %in% bioclim_indices) {
            
            pre_bio25 <- quarter_stats %>%
                              dplyr::group_by(sample.id) %>%
                              dplyr::filter(q_tot_rain == min(q_tot_rain)) %>%
                              dplyr::summarise(q_av_rad = mean(q_av_rad), .groups = "drop")
            
            results_list[["25"]] <- pre_bio25 %>%
                                          dplyr::rename(bio25 = q_av_rad)
            
            rm(pre_bio25)
      }
      #----
         
      
      
      # Mean Quarterly Radiation for the Warmest Quarter  -  BIO26      ----
      #   -  Equal to the quarterly mean of daily radiation for the quarter with the highest quarterly mean of daily average temperature. 
      if (26 %in% bioclim_indices) {
            
            pre_bio26 <- quarter_stats %>%
                              dplyr::group_by(sample.id) %>%
                              dplyr::filter(q_av_temp == max(q_av_temp)) %>%
                              dplyr::summarise(q_av_rad = mean(q_av_rad), .groups = "drop")
            
            results_list[["26"]] <- pre_bio26 %>%
                                          dplyr::rename(bio26 = q_av_rad)
            
            rm(pre_bio26)
      }
      #----
        
      
      
      # Mean Quarterly Radiation for the Coldest Quarter  -  BIO27      ----
      #   -  Equal to the quarterly mean of daily radiation for the quarter with the lowest quarterly mean of daily average temperature.
      if (27 %in% bioclim_indices) {
            
            pre_bio27 <- quarter_stats %>%
                              dplyr::group_by(sample.id) %>%
                              dplyr::filter(q_av_temp == min(q_av_temp)) %>%
                              dplyr::summarise(q_av_rad = mean(q_av_rad), .groups = "drop")
            
            results_list[["27"]] <- pre_bio27 %>%
                                          dplyr::rename(bio27 = q_av_rad)
            
            rm(pre_bio27)
      }
      #----
      
      
      ############################################    Compiling Results    ##############################################
      
      
      # Message if No Indices Calculated    ----
      if (length(results_list) == 0) {
            stop("No indices computed. Check bioclim_indices argument.")
      }
      #----
      
      
      
      # Binding all dataframes together and Saving    ----
      results_df <- results_list %>% purrr::reduce(full_join, by = "sample.id")
      
      
      
      # Selecting collumns to retain based on user selection:
      requested_cols <- paste0("bio", bioclim_indices)
      
      
      # Selecting only requested collumns to remain in the dataframe:
      results_df <- results_df %>%
                        dplyr::select(sample.id, all_of(requested_cols))
      
      
      
      # Saving the Object
      saveRDS(results_df, file = output_directory)
      
      
      return(results_df)
      #----
}
      
```
  



```{r testing the function}

# Test run:


test_assign_clim.data
str(test_assign_clim.data)


test_bioclim_calc <- compute_ind_bioclims(test_assign_clim.data, 
                                          bioclim_indices = c(1, 3, 8, 9, 10, 14, 15, 22, 25), 
                                          var.names = c("tmin", "tmax", "daily_rain", "radiation"),
                                          output_directory = "github/individual_bioclimatic_indices_computed.RDS")


test_bioclim_calc




```
#. 





# compute_centroid_bioclims

This function computes bioclimatic indices for each centroid for each calendar year of the time series

Computes BIOCLIM 1-27 using daily values for maximum temperature, minimum temperature, precipitation and radiation, allowing the user to decide which BIOCLIM indices they would like to compute. 

In order to compute all indices, the function requires all 4 of the above described climate variables, however, the function will only fail if the user does not provide the specific climate variables required for the indices they have selected are missing. 

The function optionally allows the computing of averages over time for each grid cell, computed as the average bioclim value for each cell. 


```{r function for computing bioclimatic indices for each year from daily climate data - FOR CENTROIDS/GRID CELLS - CALENDAR YEAR}


# this function will Compute BIO climatic Indices 1-27 for each centroid for each calendar year of the climate data annual climate period, produced earlier by the "compile_raster_dfs" function



# Function INPUT DATA     ----

#    -    centroid_clim.data        -  The dataframe produced by the extract_and_compile_clim.data


#...............................................................................................................................................................................


#    -    bioclim_indices           -     A vector of numbers identifying which bioclimatic indices the user wants the function to compute:
#                                         Example:    c(1, 2, 3, 4, 5, 6, 7, 8, 15, 22, 21, 26)
#                                         -  Indices Range from 1 through to 27:
#                                                     1 - 11 = Temperature Based Indices
#                                                     12 - 19 = Precipitation Indices
#                                                     20 - 27 = Radiation Indices
#                                         -  NOTE: Different Indices Require Different Variables to be included:
                                                #    BIO1  -     Max Temp  |  Min Temp
                                                #    BIO2  -     Max Temp  |  Min Temp
                                                #    BIO3  -     Max Temp  |  Min Temp
                                                #    BIO4  -     Max Temp  |  Min Temp 
                                                #    BIO5  -     Max Temp
                                                #    BIO6  -     Min Temp
                                                #    BIO7  -     Max Temp  |  Min Temp
                                                #    BIO8  -     Max Temp  |  Min Temp | Precipitation
                                                #    BIO9  -     Max Temp  |  Min Temp | Precipitation
                                                #    BIO10  -    Max Temp
                                                #    BIO11  -    Min Temp
                                                #    BIO12  -    Precipitation
                                                #    BIO13  -    Precipitation
                                                #    BIO14  -    Precipitation
                                                #    BIO15  -    Precipitation
                                                #    BIO16  -    Precipitation
                                                #    BIO17  -    Precipitation
                                                #    BIO18  -    Precipitation  |  Max Temp
                                                #    BIO19  -    Precipitation  |  Min Temp
                                                #    BIO20  -    Radiation
                                                #    BIO21  -    Radiation
                                                #    BIO22  -    Radiation
                                                #    BIO23  -    Radiation
                                                #    BIO24  -    Radiation  |  Precipitation
                                                #    BIO25  -    Radiation  |  Precipitation
                                                #    BIO26  -    Radiation  |  Max Temp
                                                #    BIO27  -    Radiation  |  Min Temp


#...............................................................................................................................................................................


#    -    var.names                 -     A vector of the variables to be used to compute bioclimatic indices for each Individual:
#                                         -  Must Include one or more of the following:
#                                                     - Maximum Temperature         -     tmax (AWAP) or max_temp (SILO) or t_max (ANUCLIM)
#                                                     - Minimum Temperature         -     tmin (AWAP) or min_temp (SILO) or t_min (ANUCLIM)
#                                                     - Precipitation               -     precip (AWAP) or daily_rain (SILO) or rain (ANUCLIM)
#                                                     - Radiation                   -     radiation (SILO) or srad (ANUCLIM)
#                                         - The function will handle having multiple synonomous variables (see above) in the dataframe, using only those called in "var.names"
#                                               NOTE: If there are several version of the same climate variable, the function will force an error.
#                                                    BOM AWAP Variable    |    SILO Variable    |    ANUCLIM          
#                                       ..................................|.........................................
#                                                    precip               |    daily_rain       |    rain
#                                                    tmax                 |    max_temp         |    t_max
#                                                    tmin                 |    min_temp         |    t_min
#                                                                         |    radiation        |    srad


#...............................................................................................................................................................................


#    -    av_period_start           -    A numerical value describing the year which starts the averaging period sequence


#...............................................................................................................................................................................


#    -    av_period_end             -    A numerical value describing the final year in the averaging period sequence


#...............................................................................................................................................................................


#    -    av_period_by              -    A numerical value describing how many years of indices should be averaged to produce the final detaset. 
#                                               -  Indices are calculated for each year prior to averaging across user defined periods. 
#                                               -  If you wanted decadal averages for the indices, then averaging-period = 10
#                                               -  If you don't want the values averaged, then averaging_period = 1


#...............................................................................................................................................................................


#    -    output_directory          -    a path (including file name and extension) to the location where the output will be saved (as .RDS)

#----








compute_centroid_bioclims <- function(centroid_clim.data, bioclim_indices, var.names, av_period_start, av_period_end, av_period_by, output_directory) {
      
      
      # Loading required Packages:
      library(tidyverse)
      
      
      # Creating a copy of the data to manipulate
      clim <- centroid_clim.data
      
      #Initialising a list to output results.
      results_list <- list()

      
      # checking User input is valid   ----
      
      # Bioclim indices
      if(all(bioclim_indices %in% c(1:27)) == FALSE) {
            stop("Invalid Bioclimatic Indice Values. Values of Bioclimatic Indices should Range from 1 - 27.")
      }
      
      
      
      # Climate variables:
      valid_var.names <- c("tmax", "tmin", "precip", "max_temp", "min_temp", "daily_rain", "radiation")
      
      if(all(var.names %in% valid_var.names) == FALSE) {
            stop("Invalid Climate Variable Names Supplied. Check supplied variable names.")
      }
      #----
      
      
      
      # Clearing Potential Duplicate Climate values (BOM AWAP vs SILO vs ANUClim) ----
      
      # Define standardization rules: canonical name -> alternative names
      standardization_map <- list(
        precip = c("rain", "daily_rain"),
        tmax = c("max_temp", "t_max"),
        tmin = c("min_temp", "t_min"),
        rad = c("srad", "radiation")
      )
      
      # Identify variables actually present in the dataset
      present_vars <- names(clim)
      
      # Process each canonical variable
      for (canonical in names(standardization_map)) {
        
        alternatives <- standardization_map[[canonical]]
        
        # Find which version exists in var.names (if any)
        existing_in_varnames <- c(canonical, alternatives)[c(canonical, alternatives) %in% var.names]
        
        if (length(existing_in_varnames) > 0) {
          
          primary_var <- existing_in_varnames[1]  # The one specified in var.names
          
          # Remove all other alternatives that exist in the dataset
          vars_to_remove <- setdiff(c(canonical, alternatives), primary_var)
          vars_to_remove <- intersect(vars_to_remove, present_vars)
          
          if (length(vars_to_remove) > 0) {
            clim <- clim %>% 
              dplyr::select(-all_of(vars_to_remove))
            
            message(paste0("Removed duplicate variable(s) '", 
                           paste(vars_to_remove, collapse = "', '"), 
                           "' because '", primary_var, "' is specified in var.names"))
          }
          
          # Rename to canonical form if needed
          if (primary_var != canonical && primary_var %in% names(clim)) {
            clim <- clim %>%
              dplyr::rename(!!canonical := !!primary_var)
            
            var.names[var.names == primary_var] <- canonical
            
            message(paste0("Standardized '", primary_var, "' to '", canonical, "'"))
          }
        }
      }
      #----
      
      
      # Standardising overlap names - Precipitation    ----
      if ("daily_rain" %in% var.names) {
            
             clim <- clim %>%
                   dplyr::rename(precip = daily_rain)
             
             var.names[var.names == "daily_rain"] <- "precip"
      }
      
      # Standardising overlap names - Max Temp    ----
      if ("max_temp" %in% var.names) {
            
             clim <- clim %>%
                   dplyr::rename(tmax = max_temp)
             
             var.names[var.names == "max_temp"] <- "tmax"
      }
      
      # Standardising overlap names - Min Temp    ----
      if ("min_temp" %in% var.names) {
            
            clim <- clim %>%
                  dplyr::rename(tmin = min_temp)
            
            var.names[var.names == "min_temp"] <- "tmin"
            
      }
      
      # Shortening Variable names - Radiation    ----
      if ("radiation" %in% var.names) {
            
            clim <- clim %>%
                  dplyr::rename(rad = radiation)
            
            var.names[var.names == "radiation"] <- "rad"
            
      }
      #----

      
      
      # Checking That the variables required to calculate requested indices are present    ----
      
      # Defining which indices require which variables:
      indices_depend_max.temp <- c(1, 2, 3, 4, 5, 7, 8, 9, 10, 18, 26)
      indices_depend_min.temp <- c(1, 2, 3, 4, 6, 7, 8, 9, 11, 19, 27)
      indices_depend_precip <- c(8, 9, 12, 13, 14, 15, 16, 17, 18, 19, 24, 25)
      indices_depend_rad <- c(20, 21, 22, 23, 24, 25, 26, 27)
      
      
      
      # Check that each indice to be computed has the required variables present:
      for(i in bioclim_indices) {
            
            if(i %in% indices_depend_max.temp & !("tmax" %in% var.names)) {
                  stop("Maximum Temperature Variables Required to Compute BIO", i, " Required - Revise Input Variables.")
            }
            
            if(i %in% indices_depend_min.temp & !("tmin" %in% var.names)) {
                  stop("Minimum Temperature Variables Required to Compute BIO", i, " Required - Revise Input Variables.")
            }
            
            if(i %in% indices_depend_precip & !("precip" %in% var.names)) {
                  stop("Precipitation Variables Required to Compute BIO", i, " Required - Revise Input Variables.")
            }
            
            if(i %in% indices_depend_rad & !("rad" %in% var.names)) {
                  stop("Radiation Variables Required to Compute BIO", i, " Required - Revise Input Variables.")
            }
      }
      #----
      
      
      
      
      # Formatting all Required Date and Time data for the climate data    ----
      clim$clim_date <- date(clim$clim_date)
      clim$clim_year <- year(clim$clim_date)
      clim$clim_month <- month(clim$clim_date)
      clim$clim_m.day <- day(clim$clim_date)
      #----
      
      
      
      
      ############################################    Monthly Aggregations    ##############################################
      
      # Temperature Monthly Aggregations      ----
      if("tmax" %in% var.names & "tmin" %in% var.names) {
            
            # Computing Daily Mean Temperature
            clim$daily_av_temp <- (clim$tmin + clim$tmax)/2
            clim$diurnal_range <- clim$tmax - clim$tmin
            clim$daily_av_temp_k <- clim$daily_av_temp + 273.15
            
            
            # Monthly Aggregations
            monthly_av_temp <- aggregate(daily_av_temp ~ centroid.id + clim_month + clim_year, data = clim, FUN = mean)%>%
                                                                              dplyr::rename(month_av_temp = daily_av_temp)
            
            monthly_max_temp <- aggregate(tmax ~ centroid.id + clim_month + clim_year, data = clim, FUN = mean)%>%
                                                                              dplyr::rename(month_max_temp = tmax)
            
            monthly_min_temp <- aggregate(tmin ~ centroid.id + clim_month + clim_year, data = clim, FUN = mean)%>%
                                                                              dplyr::rename(month_min_temp = tmin)
            
            monthly_av_temp_k <- aggregate(daily_av_temp_k ~ centroid.id + clim_month + clim_year, data = clim, FUN = mean)%>%
                                                                              dplyr::rename(month_av_temp_k = daily_av_temp_k)
            
            # Merging back into Clim:
            clim <- clim %>%
                        left_join(monthly_av_temp, by = c("centroid.id", "clim_month", "clim_year")) %>%
                        left_join(monthly_max_temp, by = c("centroid.id", "clim_month", "clim_year")) %>%
                        left_join(monthly_min_temp, by = c("centroid.id", "clim_month", "clim_year")) %>%
                        left_join(monthly_av_temp_k, by = c("centroid.id", "clim_month", "clim_year"))
      
            
      } else if ("tmax" %in% var.names) {

            # Computing Monthly Aggregation
            monthly_max_temp <- aggregate(tmax ~ centroid.id + clim_month + clim_year, data = clim, FUN = mean)%>%
                                                                              dplyr::rename(month_max_temp = tmax)
            
            # Merging back into Clim:
            clim <- clim %>%
                        left_join(monthly_max_temp, by = c("centroid.id", "clim_month", "clim_year"))
            
      } else if ("tmin" %in% var.names) {

            # Computing Monthly Aggregation
            monthly_min_temp <- aggregate(tmin ~ centroid.id + clim_month + clim_year, data = clim, FUN = mean)%>%
                                                                              dplyr::rename(month_min_temp = tmin)
            
            # Merging back into Clim:
            clim <- clim %>%
                        left_join(monthly_min_temp, by = c("centroid.id", "clim_month", "clim_year"))            
            
      }
      #----
      
      
      # Precipitation Monthly Aggregations      ----
      if("precip" %in% var.names) {
            
            # Monthly Aggregations:
            monthly_av_rain <- aggregate(precip ~ centroid.id + clim_month + clim_year, data = clim, FUN = mean)%>%
                                                                              dplyr::rename(month_av_rain = precip)
            
            monthly_tot_rain <- aggregate(precip ~ centroid.id + clim_month + clim_year, data = clim, FUN = sum)%>%
                                                                              dplyr::rename(month_tot_rain = precip)
            
            # merging back into clim:
            clim <- clim %>% 
                        left_join(monthly_av_rain, by = c("centroid.id", "clim_month", "clim_year")) %>%
                        left_join(monthly_tot_rain, by = c("centroid.id", "clim_month", "clim_year"))
      }
      #----
      
      
      # Radiation Monthly Aggregations      ----
      if("rad" %in% var.names) {
            
            # Monthly Aggregations:
            monthly_av_rad <- aggregate(rad ~ centroid.id + clim_month + clim_year, data = clim, FUN = mean)%>%
                                                                              dplyr::rename(month_av_rad = rad)
            
            
            # merging back into clim:
            clim <- clim %>% 
                        left_join(monthly_av_rad, by = c("centroid.id", "clim_month", "clim_year"))
      }
      #----
      
      
      
      ############################################    Quarterly Aggregations    ##############################################
      
      # Quarter Definitions     ----
      quart_combos <- list(c(1, 2, 3),  c(2, 3, 4), 
                           c(3, 4, 5),  c(4, 5, 6), 
                           c(5, 6, 7),  c(6, 7, 8), 
                           c(7, 8, 9),  c(8, 9, 10), 
                           c(9, 10, 11),  c(10, 11, 12),
                           c(11, 12, 1),   c(12, 1, 2))
      #----
      
      
      # Running through each quarter combination and computing values for that quarter    ----
      
      # Initialising an Empty List:
      q_results_list <- list()
      
      for (months in quart_combos) {
            
            
            # Restricting the dataframe to only those months found in this quarter:
            q_filtered.df <- clim %>%
                              dplyr::filter(clim_month %in% months)
            
            
            # Initialising an Empty List
            q_list <- list()
            
            
            # Temperature-based aggregations
            if("tmax" %in% var.names) {
                  q_list[[ "q_max_temp" ]] <- aggregate(tmax ~ centroid.id + clim_year, data = q_filtered.df, FUN = mean) %>%
                                                                  dplyr::rename(q_max_temp = tmax)
            }
            
            if("tmin" %in% var.names) {
                  q_list[[ "q_min_temp" ]] <- aggregate(tmin ~ centroid.id + clim_year, data = q_filtered.df, FUN = mean) %>%
                                                                  dplyr::rename(q_min_temp = tmin)
            }
              
            if(all(c("tmax","tmin") %in% var.names)) {
                  q_list[[ "q_av_temp" ]] <- aggregate(daily_av_temp ~ centroid.id + clim_year, data = q_filtered.df, FUN = mean) %>%
                                                                  dplyr::rename(q_av_temp = daily_av_temp)
            }
            

            
            # Precipitation-based aggregations ----
            if("precip" %in% var.names) {
                  q_list[[ "q_tot_rain" ]] <- aggregate(precip ~ centroid.id + clim_year, data = q_filtered.df, FUN = sum) %>%
                                                                  dplyr::rename(q_tot_rain = precip)
            }
            
            
            
            # Radiation-based aggregations ----
            if("rad" %in% var.names) {
                  q_list[[ "q_av_rad" ]] <- aggregate(rad ~ centroid.id + clim_year, data = q_filtered.df, FUN = mean) %>%
                                                                  dplyr::rename(q_av_rad = rad)
            }
            
           
            # Combine into a single DF for this quarter
            if(length(q_list) > 0) {
                  q_df <- q_list %>% purrr::reduce(full_join, by = c("centroid.id", "clim_year"))
                  q_results_list[[ paste(months, collapse = "-") ]] <- q_df
            }
      }  
         
      
      # Bind All the Quarter Results:
      quarter_stats <- dplyr::bind_rows(q_results_list, .id = "quarter")
      quarter_stats$quarter <- as.factor(quarter_stats$quarter)
      
      # Rename columns
      names(quarter_stats) <- make.names(names(quarter_stats), unique = TRUE)
      #----
      
      
      ############################################    TEMPERATURE  -  Indice Calculations    ##############################################
      
      # Annual Mean Temperature - BIO1      ----
      #   -  Equal to the annual mean of the daily average temperature, calculated as the average between maximum and minimum temperature. 
      if (1 %in% bioclim_indices) {
            results_list[["1"]] <- aggregate(daily_av_temp ~ centroid.id + clim_year, data = clim, FUN = mean) %>%
                                                                              dplyr::rename(bio1 = daily_av_temp)
      }
      #----
      
      
      
      # Mean Annual Diurnal Range  -  BIO2      ----
      #   -  Equal to the annual average of the difference between daily maximum and minimum temperatures. 
      if (any(c(2, 3) %in% bioclim_indices)) {      # BIO3 Depends on BIO2 to be computed - therefore, we include this in the conditional

            results_list[["2"]] <- aggregate(diurnal_range ~ centroid.id + clim_year, data = clim, FUN = mean) %>%
                                                                              dplyr::rename(bio2 = diurnal_range)
      }
      #----
      
      
      
            ####    BIO3 computer AFTER BIO7 to avoid unnecssary Code
      
      
      
      
      # Temperature Seasonality (Standard Deviation)  -  BIO4      ----
      #   -  Equal to the SD of the monthly average of daily average temperatures (calculated as the mean of the maximum and minimum temperatures).
      if (4 %in% bioclim_indices) {
            
            # computing the standard deviation in monthly average temp in Kelvin
            month_av_temp_K_sd <- aggregate(month_av_temp_k ~ centroid.id + clim_year, data = clim, FUN = sd) %>%
                                    dplyr::rename(month_av_K_sd = month_av_temp_k)
            
            # computing the yearly average of monthly average temp in Kelvin
            yearly_av_tempk <- aggregate(month_av_temp_k ~ centroid.id + clim_year, data = clim, FUN = mean) %>%
                                    dplyr::rename(year_av_temp_k = month_av_temp_k)
            
            # merging dataframes together
            av_tempk_cv <- merge(month_av_temp_K_sd, yearly_av_tempk, by = c("centroid.id", "clim_year"))
            
            # computing BIO4 - 
            av_tempk_cv$bio4 <- (av_tempk_cv$month_av_K_sd/av_tempk_cv$year_av_temp_k)*100
            
            # saving Result
            results_list[["4"]] <- av_tempk_cv %>%
                                          dplyr::select(centroid.id, clim_year, bio4)
            
            # removing all objects:
            rm(month_av_temp_K_sd, yearly_av_tempk, av_tempk_cv)
      }
      #----
      
      
        
      
      # Mean Maximum Temperature of Warmest Month - BIO5      ----
      #   -  Equal to the monthly average maximum daily temperature for the month with the highest monthly average daily maximum temperature. 
      if (any(c(5, 7, 3) %in% bioclim_indices)) {      # BIO7 and BIO3 Depend on BIO5 to be computed - therefore, we include this in the conditional
            
            results_list[["5"]] <- aggregate(month_max_temp ~ centroid.id + clim_year, data = clim, FUN = max) %>%
                                                                        dplyr::rename(bio5 = month_max_temp)
      }
      #----
      
      

      
      # Mean Minimum Temperature of Coldest Month - BIO6      ----
      #   -  Equal to the monthly average minimum daily temperature for the month with the lowest monthly average daily minimum temperature. 
      if (any(c(6, 7, 3) %in% bioclim_indices)) {      # BIO7 and BIO3 Depend on BIO6 to be computed - therefore, we include this in the conditional
            
            results_list[["6"]] <- aggregate(month_min_temp ~ centroid.id + clim_year, data = clim, FUN = min) %>%
                                                                        dplyr::rename(bio6 = month_min_temp)
      }
      #----
        
      
      
      # Annual Temperature Range - BIO7      ----
      #   -  Equal to the difference between the average monthly maximum daily temperature for the warmest month 
      #                                                     and the average monthly minimum daily temperature for the coldest month (BIO5 - BIO6)
      if (any(c(7, 3) %in% bioclim_indices)) {      # BIO3 Depends on BIO7 to be computed - therefore, we include this in the conditional
            
            # merging Bio5 and BIO6
            pre_bio7 <- merge(results_list[["5"]], results_list[["6"]], by = c("centroid.id", "clim_year"))
            
            # Computing bio7
            pre_bio7$bio7 <- pre_bio7$bio5 - pre_bio7$bio6
            
            # Saving the result
            results_list[["7"]] <- pre_bio7 %>%
                                          dplyr::select(centroid.id, clim_year, bio7)
            
            # cleaning up environment
            rm(pre_bio7)
      }
      #----
      
      
      
      # Isothermality (The Daily Temperature Range Relative to Annual Temperature Range)  -  BIO3      ----
      #   -  Equal to the ratio of the mean annual diurnal range to the Annual temperature range (BIO2 / BIO7)
      if (3 %in% bioclim_indices) {
            
            # merging Bio5 and BIO6
            pre_bio3 <- merge(results_list[["2"]], results_list[["7"]], by = c("centroid.id", "clim_year"))
            
            # Computing bio7
            pre_bio3$bio3 <- (pre_bio3$bio2 / pre_bio3$bio7)*100
            
            # Saving the result
            results_list[["3"]] <- pre_bio3 %>%
                                          dplyr::select(centroid.id, clim_year, bio3)
            
            # cleaning up environment
            rm(pre_bio3)
      }
      #----
       
      
      
      # Mean Average Daily Temperature of Wettest Quarter - BIO8      ----
      #   -  Equal to the quarterly mean of daily average temperature for the quarter of the year where precipitation was highest. 
      if (8 %in% bioclim_indices) {
            
            pre_bio8 <- quarter_stats %>%
                              dplyr::group_by(centroid.id, clim_year) %>%
                              dplyr::filter(q_tot_rain == max(q_tot_rain)) %>%
                              dplyr::summarise(q_av_temp = mean(q_av_temp), .groups = "drop")
            
            results_list[["8"]] <- pre_bio8 %>%
                                          dplyr::rename(bio8 = q_av_temp)
            
            rm(pre_bio8)
      }
      #----
        
      
      
      
      # Mean Average Daily Temperature of driest Quarter - BIO9      ----
      #   -  Equal to the quarterly mean of daily average temperature for the quarter of the year where precipitation was lowest. 
      if (9 %in% bioclim_indices) {
            
            pre_bio9 <- quarter_stats %>%
                              dplyr::group_by(centroid.id, clim_year) %>%
                              dplyr::filter(q_tot_rain == min(q_tot_rain)) %>%
                              dplyr::summarise(q_av_temp = mean(q_av_temp), .groups = "drop")
            
            results_list[["9"]] <- pre_bio9 %>%
                                          dplyr::rename(bio9 = q_av_temp)
            
            rm(pre_bio9)
      }
      #----
        
      
      
      
      # Mean Average Daily Temperature of Warmest Quarter - BIO10      ----
      #   -  Equal to the highest quarterly mean of daily average temperature. 
      if (10 %in% bioclim_indices) {
            
            pre_bio10 <- quarter_stats %>%
                              dplyr::group_by(centroid.id, clim_year) %>%
                              dplyr::filter(q_av_temp == max(q_av_temp)) %>%
                              dplyr::summarise(q_av_temp = mean(q_av_temp), .groups = "drop")
            
            results_list[["10"]] <- pre_bio10 %>%
                                          dplyr::rename(bio10 = q_av_temp)
            
            rm(pre_bio10)
      }
      #----
       
      
      
      
      # Mean Average Daily Temperature of Coldest Quarter - BIO11      ----
      #   -  Equal to the lowest quarterly mean of daily average temperature. 
      if (11 %in% bioclim_indices) {
            
            pre_bio11 <- quarter_stats %>%
                              dplyr::group_by(centroid.id, clim_year) %>%
                              dplyr::filter(q_av_temp == min(q_av_temp)) %>%
                              dplyr::summarise(q_av_temp = mean(q_av_temp), .groups = "drop")
            
            results_list[["11"]] <- pre_bio11 %>%
                                          dplyr::rename(bio11 = q_av_temp)
            
            rm(pre_bio11)
      }
      #----
      
      
      
      
      
      ############################################    PRECIPITATION  -  Indice Calculations    ##############################################
      
      # Total Annual Precipitation  -  BIO12      ----
      #   -  Equal to the annual sum of all daily precipitation. 
      if (12 %in% bioclim_indices) {
            
            results_list[["12"]] <- aggregate(precip ~ centroid.id + clim_year, data = clim, FUN = sum) %>%
                                                                              dplyr::rename(bio12 = precip)
      }
      #----
      
      
      
      # Total Precipitation During Wettest Month  -  BIO13      ----
      #   -  Equal to the monthly sum of all daily precipitation during the month with the highest precipitation
      if (13 %in% bioclim_indices) {
            
            results_list[["13"]] <- aggregate(month_tot_rain ~ centroid.id + clim_year, data = clim, FUN = max) %>%
                                                                              dplyr::rename(bio13 = month_tot_rain)
      }
      #----
      
      
      
      # Total Precipitation During Driest Month  -  BIO14      ----
      #   -  Equal to the monthly sum of all daily precipitation during the month with the lowest precipitation
      if (14 %in% bioclim_indices) {
            
            results_list[["14"]] <- aggregate(month_tot_rain ~ centroid.id + clim_year, data = clim, FUN = min) %>%
                                                                              dplyr::rename(bio14 = month_tot_rain)
      }
      #----
      
      
        
      # Seasonality Index for Rainfall  -  BIO15      ----
      #   -  Equal to the Standard Deviation of Monthly totals of precipitation for the year, divided by the average monthly precipitation
      #                                         for the year (added to 1 to avoid strange negative index values), 
      #                                         multiplied by 100 to be expressed as a percentage.
      if (15 %in% bioclim_indices) {
            
            # computing the standard deviation in monthly total rainfall
            monthly_tot_rain_sd <- aggregate(month_tot_rain ~ centroid.id + clim_year, data = clim, FUN = sd) %>%
                                                      dplyr::rename(month_tot_rain_sd = month_tot_rain)
            
            # computing the yearly average of monthly average temp in Kelvin
            yearly_av_month_rain <- aggregate(month_tot_rain ~ centroid.id + clim_year, data = clim, FUN = mean) %>%
                                                      dplyr::rename(year_av_month_rain = month_tot_rain)
            
            # merging dataframes together
            tot_rain_cv <- merge(monthly_tot_rain_sd, yearly_av_month_rain, by = c("centroid.id", "clim_year"))
            
            # computing BIO4 - 
            tot_rain_cv$bio15 <- (tot_rain_cv$month_tot_rain_sd/tot_rain_cv$year_av_month_rain)*100
            
            # saving Result
            results_list[["15"]] <- tot_rain_cv %>%
                                          dplyr::select(centroid.id, clim_year, bio15)
            
            # removing all objects:
            rm(monthly_tot_rain_sd, yearly_av_month_rain, tot_rain_cv)
      }
      #----
        
      
      
      # Precipitation for Wettest Quarter - BIO16      ----
      #   -  Equal to the total precipitation for the quarter (3 consecutive month period) with the highest total precipitation
      if (16 %in% bioclim_indices) {
            
            pre_bio16 <- quarter_stats %>%
                              dplyr::group_by(centroid.id, clim_year) %>%
                              dplyr::filter(q_tot_rain == max(q_tot_rain)) %>%
                              dplyr::summarise(q_tot_rain = mean(q_tot_rain), .groups = "drop")
            
            results_list[["16"]] <- pre_bio16 %>%
                                          dplyr::rename(bio16 = q_tot_rain)
            
            rm(pre_bio16)
      }
      #----
      
      
      
      # Precipitation for the Driest Quarter - BIO17      ----
      #   -  Equal to the total precipitation for the quarter (3 consecutive month period) with the lowest total precipitation
      if (17 %in% bioclim_indices) {
            
            pre_bio17 <- quarter_stats %>%
                              dplyr::group_by(centroid.id, clim_year) %>%
                              dplyr::filter(q_tot_rain == min(q_tot_rain)) %>%
                              dplyr::summarise(q_tot_rain = mean(q_tot_rain), .groups = "drop")
            
            results_list[["17"]] <- pre_bio17 %>%
                                          dplyr::rename(bio17 = q_tot_rain)
            
            rm(pre_bio17)
      }
      #----
      
      
      
      # Precipitation of Warmest Quarter  -  BIO18      ----
      #   -  Equal to the sum of precipitation for the warmest 3 months of the year. 
      if (18 %in% bioclim_indices) {
            
            pre_bio18 <- quarter_stats %>%
                              dplyr::group_by(centroid.id, clim_year) %>%
                              dplyr::filter(q_av_temp == max(q_av_temp)) %>%
                              dplyr::summarise(q_tot_rain = mean(q_tot_rain), .groups = "drop")
            
            results_list[["18"]] <- pre_bio18 %>%
                                          dplyr::rename(bio18 = q_tot_rain)
            
            rm(pre_bio18)
      }
      #----
        
      
      
      # Precipitation of Warmest Quarter  -  BIO19      ----
      #   -  Equal to the sum of precipitation for the coldest 3 months of the year. 
      if (19 %in% bioclim_indices) {
            
            pre_bio19 <- quarter_stats %>%
                              dplyr::group_by(centroid.id, clim_year) %>%
                              dplyr::filter(q_av_temp == min(q_av_temp)) %>%
                              dplyr::summarise(q_tot_rain = mean(q_tot_rain), .groups = "drop")
            
            results_list[["19"]] <- pre_bio19 %>%
                                          dplyr::rename(bio19 = q_tot_rain)
            
            rm(pre_bio19)
      }
      #----
      
      
      
      
      
      ############################################    RADIATION  -  Indice Calculations    ##############################################
      
      # Mean Annual Daily Radiation  -  BIO20      ----
      #   -  Equal to the annual average of daily radiation values. 
      if (20 %in% bioclim_indices) {
            
            results_list[["20"]] <- aggregate(rad ~ centroid.id + clim_year, data = clim, FUN = mean) %>%
                                                                              dplyr::rename(bio20 = rad)
      }
      #----
        
      
      
      # Mean Monthly Daily Radiation for the Month with the Highest Mean Radiation  -  BIO21      ----
      #   -  Equal to the highest monthly average of daily radiation for the year. 
      if (21 %in% bioclim_indices) {
            
            results_list[["21"]] <- aggregate(month_av_rad ~ centroid.id + clim_year, data = clim, FUN = max) %>%
                                                                              dplyr::rename(bio21 = month_av_rad)
      }
      #----
         
      
      
      # Mean Monthly Daily Radiation for the Month with the lowest Mean Radiation  -  BIO22      ----
      #   -  Equal to the lowest monthly average of daily radiation for the year. 
      if (22 %in% bioclim_indices) {
            
            results_list[["22"]] <- aggregate(month_av_rad ~ centroid.id + clim_year, data = clim, FUN = min) %>%
                                                                              dplyr::rename(bio22 = month_av_rad)
      }
      #----
        
      
      
      # Radiation seasonality  -  BIO23      ----
      #   -  Equal to the coefficient of variance for the monthly means daily radiation for the year. 
      if (23 %in% bioclim_indices) {
            
            # computing the standard deviation in monthly total rainfall
            monthly_av_rad_sd <- aggregate(month_av_rad ~ centroid.id + clim_year, data = clim, FUN = sd) %>%
                                                            dplyr::rename(month_av_rad_sd = month_av_rad)
            
            # computing the yearly average of monthly average temp in Kelvin
            yearly_av_month_rad <- aggregate(month_av_rad ~ centroid.id + clim_year, data = clim, FUN = mean) %>%
                                                      dplyr::rename(year_av_month_rad = month_av_rad)
            
            # merging dataframes together
            av_rad_cv <- merge(monthly_av_rad_sd, yearly_av_month_rad, by = c("centroid.id", "clim_year"))
            
            # computing BIO4 - 
            av_rad_cv$bio23 <- (av_rad_cv$month_av_rad_sd/av_rad_cv$year_av_month_rad)*100
            
            # saving Result
            results_list[["23"]] <- av_rad_cv %>%
                                          dplyr::select(centroid.id, clim_year, bio23)
            
            # removing all objects:
            rm(monthly_av_rad_sd, yearly_av_month_rad, av_rad_cv)
      }
      #----
        
      
      
      # Mean Quarterly Radiation for the Wettest Quarter  -  BIO24      ----
      #   -  Equal to the quarterly mean of daily radiation for the quarter with the highest quarterly total rainfall. 
      if (24 %in% bioclim_indices) {
            
            pre_bio24 <- quarter_stats %>%
                              dplyr::group_by(centroid.id, clim_year) %>%
                              dplyr::filter(q_tot_rain == max(q_tot_rain)) %>%
                              dplyr::summarise(q_av_rad = mean(q_av_rad), .groups = "drop")
            
            results_list[["24"]] <- pre_bio24 %>%
                                          dplyr::rename(bio24 = q_av_rad)
            
            rm(pre_bio24)
      }
      #----
        
      
      
      # Mean Quarterly Radiation for the Driest Quarter  -  BIO25      ----
      #   -  Equal to the quarterly mean of daily radiation for the quarter with the lowest quarterly total rainfall. 
      if (25 %in% bioclim_indices) {
            
            pre_bio25 <- quarter_stats %>%
                              dplyr::group_by(centroid.id, clim_year) %>%
                              dplyr::filter(q_tot_rain == min(q_tot_rain)) %>%
                              dplyr::summarise(q_av_rad = mean(q_av_rad), .groups = "drop")
            
            results_list[["25"]] <- pre_bio25 %>%
                                          dplyr::rename(bio25 = q_av_rad)
            
            rm(pre_bio25)
      }
      #----
         
      
      
      # Mean Quarterly Radiation for the Warmest Quarter  -  BIO26      ----
      #   -  Equal to the quarterly mean of daily radiation for the quarter with the highest quarterly mean of daily average temperature. 
      if (26 %in% bioclim_indices) {
            
            pre_bio26 <- quarter_stats %>%
                              dplyr::group_by(centroid.id, clim_year) %>%
                              dplyr::filter(q_av_temp == max(q_av_temp)) %>%
                              dplyr::summarise(q_av_rad = mean(q_av_rad), .groups = "drop")
            
            results_list[["26"]] <- pre_bio26 %>%
                                          dplyr::rename(bio26 = q_av_rad)
            
            rm(pre_bio26)
      }
      #----
        
      
      
      # Mean Quarterly Radiation for the Coldest Quarter  -  BIO27      ----
      #   -  Equal to the quarterly mean of daily radiation for the quarter with the lowest quarterly mean of daily average temperature.
      if (27 %in% bioclim_indices) {
            
            pre_bio27 <- quarter_stats %>%
                              dplyr::group_by(centroid.id, clim_year) %>%
                              dplyr::filter(q_av_temp == min(q_av_temp)) %>%
                              dplyr::summarise(q_av_rad = mean(q_av_rad), .groups = "drop")
            
            results_list[["27"]] <- pre_bio27 %>%
                                          dplyr::rename(bio27 = q_av_rad)
            
            rm(pre_bio27)
      }
      #----
      
      
      ############################################    Compiling Results    ##############################################
      
      
      # Message if No Indices Calculated    ----
      if (length(results_list) == 0) {
            stop("No indices computed. Check bioclim_indices argument.")
      }
      #----
      
      
      
      # Binding all dataframes together and Saving    ----
      results_df <- results_list %>% purrr::reduce(full_join, by = c("centroid.id", "clim_year"))
      
      
      
      # Selecting collumns to retain based on user selection:
      requested_cols <- paste0("bio", bioclim_indices)
      
      
      # Selecting only requested collumns to remain in the dataframe:
      results_df <- results_df %>%
                        dplyr::select(centroid.id, clim_year, all_of(requested_cols))
      #----
      
      
      # Averging by the user defined arguments  ----
      
      if(av_period_by == 1) {
            
            # Saving the Object
            saveRDS(results_df, file = output_directory)
            
            # Return Results
            return(results_df) 
            
            
      } else if (av_period_by < 1) {
            
            message(paste0("WARNING: Averaging Period Cannot be Less than 1", "\n", "Returning Results with av_period_by = 1"))
            
            
            # Saving the Object
            saveRDS(results_df, file = output_directory)
            
            # Return Results
            return(results_df) 
            
            
            
      } else if (av_period_by > 1) {
            
            
            # Assign each year to an averaging block
            results_df <- results_df %>%
                                    dplyr::mutate(period_floor = floor((clim_year - av_period_start) / av_period_by) * av_period_by + av_period_start) %>%
                                    dplyr::filter(clim_year >= av_period_start, clim_year <= av_period_end)
            
            
            # Averaging for within each centroid and time block:
            final_centroid_bioclim_df <- results_df %>%
                                                dplyr::group_by(centroid.id, period) %>%
                                                dplyr::summarise(across(starts_with("bio"), \(x) mean(x, na.rm = TRUE)), .groups = "drop")
            
            
            # Saving the Object
            saveRDS(final_centroid_bioclim_df, file = output_directory)
            
            # Return Results
            return(final_centroid_bioclim_df) 
      }
      #----

}

```


```{r testing the function}

# Test Run:
test_compile.raster <- readRDS("github/compiled_raster_clim_df.RDS")
str(test_compile.raster)

ind_meta <- read.csv("github/Example_metadata.csv")
str(ind_meta)






test_centroid_bioclim <- compute_centroid_bioclims(centroid_clim.data = test_compile.raster,
                                                   bioclim_indices = c(2, 3, 12, 23),
                                                   var.names = c("tmin", "tmax", "daily_rain", "radiation"),
                                                   av_period_start = 2019, av_period_end = 2020, av_period_by = 1, 
                                                   output_directory = "github/test_centroid_compute_bioclim.RDS")

test_centroid_bioclim
```

#. 











































































































































































